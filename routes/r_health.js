// Generated by CoffeeScript 1.9.2
(function() {
  var HealthCheck, ObjectId, Promise, SERVICE_NAME,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Promise = require('bluebird');

  ObjectId = require('mongodb').ObjectId;

  SERVICE_NAME = process.env.npm_package_name || "blueprint";

  HealthCheck = (function() {
    HealthCheck.deps = {
      services: ['logger', 'error', 'ses', 'lamd']
    };

    function HealthCheck(kit) {
      this._GetPing = bind(this._GetPing, this);
      this._GetLogs = bind(this._GetLogs, this);
      this._GetDebug = bind(this._GetDebug, this);
      this._ServiceHealth = bind(this._ServiceHealth, this);
      this.E = kit.services.error;
      this.log = kit.services.logger.log;
      this.lamd = kit.services.lamd;
      this.ses = kit.services.ses;
      this.ses_email_config = kit.services.config.ses.emails;
      this.config = kit.services.config;
      this.all_services = kit.services;
      this.services = {};
      this.endpoints = {
        getLogs: {
          verb: 'get',
          route: '/Logs',
          use: true,
          wrap: 'default_wrap',
          version: {
            any: this._GetLogs
          },
          sql_conn: false,
          auth_required: false
        },
        pingAuth: {
          verb: 'get',
          route: '/PingAuth',
          use: true,
          wrap: 'default_wrap',
          version: {
            any: this._GetPing
          },
          sql_conn: false,
          auth_required: true
        },
        getPing: {
          verb: 'get',
          route: '/Ping',
          use: true,
          wrap: 'default_wrap',
          version: {
            any: this._GetPing
          },
          sql_conn: false,
          auth_required: false
        },
        getDebug: {
          verb: 'get',
          route: '/Debug',
          lamd: false,
          use: true,
          wrap: 'default_wrap',
          version: {
            any: this._GetDebug
          },
          sql_conn: false,
          auth_required: false
        },
        getHealth: {
          verb: 'get',
          route: '/Health',
          lamd: false,
          use: true,
          wrap: 'default_wrap',
          version: {
            any: this._ServiceHealth
          },
          sql_conn: true,
          auth_required: false
        }
      };
    }

    HealthCheck.prototype.server_init = function() {
      var nm, results;
      results = [];
      for (nm in this.all_services) {
        if (typeof this.all_services[nm].HealthCheck === 'function') {
          results.push(this.services[nm] = this.all_services[nm]);
        }
      }
      return results;
    };

    HealthCheck.prototype._ServiceHealth = function(ctx, pre_loaded) {
      var f, nm, p, send, use_doc;
      use_doc = {
        params: {
          any: '{ANY} - reflected back in params:',
          service: '{String} - optional service name e.g. RunQueue to query for health-check',
          red: '{Number} - optional, status code when service is "red"',
          yellow: '{Number} - optional, status code when service is "yellow"'
        },
        response: {
          success: '{Bool}',
          params: '{Ojbect}',
          health: '{Object}'
        }
      };
      if (ctx === 'use') {
        return use_doc;
      }
      f = 'R_Status:_Get:';
      p = ctx.p;
      send = {
        success: false,
        service_name: SERVICE_NAME,
        params: p,
        service: false,
        services: (function() {
          var results;
          results = [];
          for (nm in this.services) {
            results.push(nm);
          }
          return results;
        }).call(this)
      };
      return Promise.resolve().bind(this).then(function() {
        if (!(p.service in this.services)) {
          return false;
        }
        return this.services[p.service].HealthCheck(ctx);
      }).then(function(result) {
        if (result !== false) {
          if (result !== false) {
            send.service = result;
          }
          if ((p.red != null) && (result != null ? result.status : void 0) === 'r') {
            ctx.res.status(Number(p.red));
          }
          if ((p.yellow != null) && (result != null ? result.status : void 0) === 'y') {
            ctx.res.status(Number(p.yellow));
          }
        }
        send.success = true;
        return {
          send: send
        };
      });
    };

    HealthCheck.prototype._GetDebug = function(ctx, pre_loaded) {
      var f, len, p, ref, send, use_doc;
      use_doc = {
        params: {
          device: '{String}-FUTURE',
          req_uuid: '{String}'
        },
        response: {
          success: '{Bool}',
          debug: '{Array}'
        }
      };
      if (ctx === 'use') {
        return use_doc;
      }
      f = 'R_Debug:_Get:';
      p = ctx.p;
      send = {
        success: true,
        debug: []
      };
      len = (ref = p.req_uuid) != null ? ref.length : void 0;
      if (len !== 'a27af922-b891-45e7-b422-b50192db1928'.length) {
        throw new this.E.InvalidArg('req_uuid:' + len);
      }
      return Promise.resolve().bind(this).then(function() {
        var hint, method, options, projection, query, sort;
        method = 'find';
        query = {
          "_id": p.req_uuid
        };
        projection = {};
        options = {};
        hint = {};
        sort = {};
        return this.lamd.read_deep(ctx, method, query, projection, options, hint, sort);
      }).then(function(db_results) {
        send.debug = db_results;
        return {
          send: send
        };
      });
    };

    HealthCheck.prototype._GetLogs = function(ctx, pre_loaded) {
      var f, hint, lamd_results, method, nm, options, p, projection, query, ref, ref1, ref2, ref3, ref4, sort, subject, success, type_map, use_doc;
      use_doc = {
        params: {
          type: '{String}'
        },
        response: {
          success: '{Bool}'
        }
      };
      if (ctx === 'use') {
        return use_doc;
      }
      f = 'R_Health:_Get:';
      p = ctx.p;
      success = false;
      lamd_results = [];
      method = "find";
      query = {};
      projection = {};
      options = {};
      hint = {};
      sort = {};
      type_map = {
        lastbad100: {
          subject: 'Last Bad Queries',
          query: {
            "statusCode": {
              $ne: 200
            }
          },
          projection: {
            "_id": 0,
            "statusCode": 1,
            "start": 1,
            "route": 1,
            "verb": 1,
            "err": 1,
            "req_uuid": 1
          },
          sort: {
            $natural: -1
          }
        },
        last100: {
          subject: 'Last Query',
          query: {},
          projection: {
            "_id": 0,
            "statusCode": 1,
            "start": 1,
            "route": 1,
            "verb": 1,
            "err": 1,
            "req_uuid": 1
          },
          sort: {
            $natural: -1
          }
        },
        deadlocks: {
          subject: 'API Deadlocks',
          query: {
            "_id": {
              "$gt": new ObjectId(Math.floor(new Date(new Date() - 1000 * 60 * 60).getTime() / 1000).toString(16) + "0000000000000000")
            },
            "err.code": "ER_LOCK_DEADLOCK"
          },
          projection: {
            "_id": 0,
            "statusCode": 1,
            "start": 1,
            "route": 1,
            "verb": 1,
            "err": 1,
            "req_uuid": 1
          },
          hint: {
            "err.code": 1
          }
        },
        daily: {
          subject: 'Daily Aggregations API',
          query: [
            {
              $match: {
                "_id": {
                  $gt: new ObjectId(Math.floor(new Date(new Date() - 1000 * 60 * 60 * 24).getTime() / 1000).toString(16) + "0000000000000000")
                },
                "statusCode": {
                  "$ne": 406
                }
              }
            }, {
              "$group": {
                "_id": {
                  "statusCode": "$statusCode",
                  "route": "$route",
                  "err": "$err.proxy_error",
                  "err_code": "$err"
                },
                "count": {
                  "$sum": 1
                }
              }
            }, {
              $sort: {
                "count": -1
              }
            }
          ],
          method: "aggregate"
        }
      };
      if (!(p.type in type_map)) {
        throw new this.E.MissingArg("Bad Health Type (options: " + ((function() {
          var results;
          results = [];
          for (nm in type_map) {
            results.push(nm);
          }
          return results;
        })()) + ") - using: " + p.type);
      }
      subject = type_map[p.type].subject;
      method = (ref = type_map[p.type].method) != null ? ref : method;
      query = type_map[p.type].query;
      projection = (ref1 = type_map[p.type].projection) != null ? ref1 : projection;
      options = (ref2 = type_map[p.type].options) != null ? ref2 : options;
      hint = (ref3 = type_map[p.type].hint) != null ? ref3 : hint;
      sort = (ref4 = type_map[p.type].sort) != null ? ref4 : sort;
      return Promise.resolve().bind(this).then(function() {
        return this.lamd.read(ctx, method, query, projection, options, hint, sort);
      }).then(function(db_results) {
        var email_results, epicmvc_tables, recipient;
        lamd_results = db_results;
        email_results = ["deadlocks", "deadlocks_backend", "daily", "daily_backend"];
        if (!(lamd_results.length > 0 && email_results.indexOf(p.type) > -1)) {
          return false;
        }
        recipient = {
          reason: subject,
          type: p.type,
          eml: this.ses_email_config.alert.To
        };
        epicmvc_tables = {
          Details: [
            {
              msg: JSON.stringify(lamd_results, null, 2)
            }
          ],
          Recipient: [recipient]
        };
        return this.ses.send('alert', epicmvc_tables);
      }).then(function() {
        success = true;
        return {
          send: {
            success: success,
            num_results: lamd_results.length,
            results: lamd_results
          }
        };
      });
    };

    HealthCheck.prototype._GetPing = function(ctx, pre_loaded) {
      var f, p, success, use_doc;
      use_doc = {
        params: {
          dummy: '{String}'
        },
        response: {
          success: '{Bool}'
        }
      };
      if (ctx === 'use') {
        return use_doc;
      }
      f = 'R_Health:_GetPing:';
      p = ctx.p;
      success = false;
      success = true;
      return {
        send: {
          success: success,
          request_count: ctx.lamd.request_count,
          request_count_high: ctx.lamd.request_count_high,
          config: {
            api: this.config.api
          }
        }
      };
    };

    return HealthCheck;

  })();

  exports.HealthCheck = HealthCheck;

}).call(this);
