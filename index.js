// Generated by CoffeeScript 1.9.2
(function() {
  var _, path, update_deps;

  _ = require('lodash');

  path = require('path');

  exports.start = function(include_server, services_enabled, routes_enabled, mysql_enabled, mysql_mods_enabled, psql_enabled, psql_mods_enabled, mongo_enabled, more_config, more_kit) {
    var ErrorMore, Kit, Logger, M, Promise, Server, config, fn, i, j, kit, len, len1, log, mod, nm, opts, q_result, ref, ref1, ref2, ref3, ref4, route, routePath, server, service, servicePath;
    if (mysql_enabled == null) {
      mysql_enabled = false;
    }
    if (mysql_mods_enabled == null) {
      mysql_mods_enabled = [];
    }
    if (psql_enabled == null) {
      psql_enabled = false;
    }
    if (psql_mods_enabled == null) {
      psql_mods_enabled = [];
    }
    if (mongo_enabled == null) {
      mongo_enabled = false;
    }
    if (more_config == null) {
      more_config = {};
    }
    if (more_kit == null) {
      more_kit = {};
    }
    server = false;
    M = require('moment');
    Promise = require('bluebird');
    _ = require('lodash');
    M.defaultFormat = 'YYYY-MM-DD HH:mm:ss';
    Kit = require('./lib/kit').Kit;
    config = (require('./config'))();
    config = _.merge(config, more_config);
    Logger = require('./lib/logger').Logger;
    ErrorMore = require('./lib/error');
    kit = new Kit;
    kit.add_service('config', config);
    kit.new_service('logger', Logger);
    kit.add_service('error', ErrorMore);
    kit.services.restify_logger = kit.services.logger;
    kit = _.merge(kit, more_kit);
    log = kit.services.logger.log;
    if (mysql_enabled) {
      config.db.mysql.enable = mysql_enabled;
    }
    config.db.mysql.mods_enabled = mysql_mods_enabled;
    if (psql_enabled) {
      config.db.psql.enable = psql_enabled;
    }
    config.db.psql.mods_enabled = psql_mods_enabled;
    if (mongo_enabled) {
      config.db.mongo.enable = mongo_enabled;
    }
    if (include_server) {
      Server = require('./lib/server').Server;
      server = new Server(kit);
      server.create();
      kit.add_service('server', server);
    }
    ref = update_deps(kit, services_enabled, routes_enabled, mysql_mods_enabled, psql_mods_enabled), services_enabled = ref[0], mysql_mods_enabled = ref[1], psql_mods_enabled = ref[2];
    for (i = 0, len = services_enabled.length; i < len; i++) {
      nm = services_enabled[i];
      mod = kit.services.config.service_modules[nm];
      if (!mod) {
        throw new Error("No such service-module: " + nm);
      }
      mod.name = nm;
      log.info("Initializing " + mod["class"] + " Service...");
      opts = mod.instConfig ? [mod.instConfig] : null;
      servicePath = path.join(config.processDir, mod.file);
      kit.new_service(mod.name, (require(servicePath))[mod["class"]], opts);
    }
    if (server) {
      server.add_restify_handlers();
    }
    if (server) {
      ref1 = kit.services;
      for (nm in ref1) {
        service = ref1[nm];
        if (!(typeof service.server_use === 'function')) {
          continue;
        }
        log.info("Calling server.use for service: " + nm);
        server.server.use(service.server_use);
      }
    }
    if (server) {
      server.parse_json();
    }
    if (server) {
      server.strip_html();
    }
    q_result = Promise.resolve().bind(this);
    ref2 = kit.services;
    fn = function(service) {
      if (typeof service.server_init === 'function') {
        q_result = q_result.then(function() {
          return service.server_init(kit);
        });
      }
      if (typeof service.server_init_promise === 'function') {
        return (function(service) {
          return q_result = service.server_init_promise(kit, q_result);
        })(service);
      }
    };
    for (nm in ref2) {
      service = ref2[nm];
      fn(service);
    }
    for (j = 0, len1 = routes_enabled.length; j < len1; j++) {
      nm = routes_enabled[j];
      mod = kit.services.config.route_modules[nm];
      if (!mod) {
        throw new Error("No such route-module: " + nm);
      }
      mod.name = nm;
      log.info("Initializing " + mod["class"] + " Routes...");
      routePath = path.join(config.processDir, mod.file);
      kit.new_route_service(mod.name, (require(routePath))[mod["class"]]);
      kit.services.wrapper.add(mod.name);
    }
    ref3 = kit.routes;
    for (nm in ref3) {
      route = ref3[nm];
      if (typeof route.server_init === 'function') {
        (function(route) {
          return q_result = q_result.then(function() {
            return route.server_init(kit);
          });
        })(route);
      }
    }
    ref4 = kit.services;
    for (nm in ref4) {
      service = ref4[nm];
      if (typeof service.server_start === 'function') {
        (function(service) {
          return q_result = q_result.then(function() {
            return service.server_start(kit);
          });
        })(service);
      }
    }
    if (server) {
      q_result = q_result.then(function() {
        var ref5;
        if ((ref5 = config.api) != null ? ref5.static_file_server : void 0) {
          server.add_static_server();
        }
        return new Promise(function(resolve, reject) {
          var err;
          try {
            return server.start(function() {
              log.info('Server listening at', server.server.url);
              return resolve(null);
            });
          } catch (_error) {
            err = _error;
            return reject(err);
          }
        });
      });
    }
    q_result = q_result.then(function() {
      log.debug('SERVER NORMAL START');
      return kit;
    });
    q_result = q_result["catch"](function(err) {
      log.error(err);
      log.error('SERVER FAILED TO INITIALIZE. EXITING NOW!');
      return process.exit(1);
    });
    return q_result;
  };

  update_deps = function(kit, services_enabled, routes_enabled, mysql_mods_enabled, psql_mods_enabled) {
    var _log, all_mods, all_present, all_services, child, children, config, dep, deps, f, i, j, k, l, len, len1, len2, len3, len4, len5, len6, len7, len8, m, min, mod, module, n, new_services, nm, o, p, present, q, ref, s2child, service, servicePath, service_to_deps, services_to_check, snm, special, start_length, try_list;
    f = '(Start)Index::update_deps:';
    config = kit.services.config;
    _log = kit.services.logger.log;
    all_mods = mysql_mods_enabled.concat(psql_mods_enabled);
    special = [];
    service_to_deps = {};
    for (i = 0, len = services_enabled.length; i < len; i++) {
      nm = services_enabled[i];
      service_to_deps[nm] = false;
    }
    if (routes_enabled.length) {
      ref = ['wrapper', 'router'];
      for (j = 0, len1 = ref.length; j < len1; j++) {
        nm = ref[j];
        service_to_deps[nm] = false;
      }
    }
    for (k = 0, len2 = routes_enabled.length; k < len2; k++) {
      nm = routes_enabled[k];
      mod = config.route_modules[nm];
      if (!mod) {
        throw new Error(f + ("No such route-module: " + nm));
      }
      servicePath = path.join(config.processDir, mod.file);
      module = require(servicePath);
      if (!(mod["class"] in module)) {
        throw new Error(f + ("Class (" + mod["class"] + ") not found in file (" + servicePath + ")"));
      }
      deps = kit.get_service_deps_needed(nm, module[mod["class"]]);
      for (l = 0, len3 = deps.length; l < len3; l++) {
        snm = deps[l];
        service_to_deps[snm] = false;
      }
    }
    for (m = 0, len4 = special.length; m < len4; m++) {
      nm = special[m];
      service_to_deps[nm] = [];
    }
    services_to_check = (function() {
      var results;
      results = [];
      for (nm in service_to_deps) {
        if (service_to_deps[nm] === false) {
          results.push(nm);
        }
      }
      return results;
    })();
    while (services_to_check.length) {
      new_services = [];
      for (n = 0, len5 = services_to_check.length; n < len5; n++) {
        nm = services_to_check[n];
        mod = config.service_modules[nm];
        if (!mod) {
          throw new Error(f + ("No such service-module: " + nm));
        }
        servicePath = path.join(config.processDir, mod.file);
        module = require(servicePath);
        if (!(mod["class"] in module)) {
          throw new Error(f + ("Class (" + mod["class"] + ") not found in file (" + servicePath + ")"));
        }
        deps = kit.get_service_deps_needed(nm, module[mod["class"]]);
        service_to_deps[nm] = deps;
        for (o = 0, len6 = deps.length; o < len6; o++) {
          dep = deps[o];
          if (!(dep in service_to_deps)) {
            service_to_deps[dep] = false;
          }
        }
      }
      services_to_check = (function() {
        var results;
        results = [];
        for (nm in service_to_deps) {
          if (service_to_deps[nm] === false) {
            results.push(nm);
          }
        }
        return results;
      })();
    }
    s2child = {};
    all_services = [];
    present = {};
    for (nm in service_to_deps) {
      deps = service_to_deps[nm];
      present[nm] = false;
      if (s2child[nm] == null) {
        s2child[nm] = [];
      }
      for (p = 0, len7 = deps.length; p < len7; p++) {
        dep = deps[p];
        if (s2child[dep] == null) {
          s2child[dep] = [];
        }
        s2child[dep].push(nm);
        present[dep] = false;
      }
    }

    /*
    	 * Assume end-user got his services listed in the right order, for now # TODO
    	for service in services_enabled when not present[ service]
    		all_services.push service # Can go anytime, but might need to be before someone else, so put first in list
    		present[ service]= true
     */
    try_list = (function() {
      var results;
      results = [];
      for (service in s2child) {
        if (!present[service]) {
          results.push(service);
        }
      }
      return results;
    })();
    while (start_length = try_list.length) {
      for (service in s2child) {
        children = s2child[service];
        if (present[service]) {
          continue;
        }
        all_present = true;
        for (q = 0, len8 = children.length; q < len8; q++) {
          child = children[q];
          if (present[child] === false) {
            all_present = false;
            break;
          }
        }
        if (!all_present) {
          continue;
        }
        if (children.length === 0) {
          all_services.push(service);
        } else {
          min = _.min((function() {
            var len9, r, results;
            results = [];
            for (r = 0, len9 = children.length; r < len9; r++) {
              child = children[r];
              results.push(all_services.indexOf(child));
            }
            return results;
          })());
          if (min < 0) {
            throw new Error(f + ("BROKEN LOGIC child=" + child));
          }
          all_services.splice(min, 0, service);
        }
        present[service] = true;
      }
      try_list = (function() {
        var results;
        results = [];
        for (service in s2child) {
          if (!present[service]) {
            results.push(service);
          }
        }
        return results;
      })();
      if (try_list.length === start_length) {
        throw new Error(f + "Some wierdness in dependancies");
      }
    }
    _log.debug(f + 'FINAL', {
      all_services: all_services,
      s2child: s2child
    });
    return [all_services, all_mods];
  };

}).call(this);
