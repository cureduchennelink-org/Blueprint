// Generated by CoffeeScript 1.9.2
(function() {
  var Promise, SqlCore, mysql,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Promise = require('bluebird');

  mysql = require('mysql');

  SqlCore = (function() {
    SqlCore.deps = {
      services: ['error', 'logger']
    };

    function SqlCore(kit, pool_opts) {
      this.method_factory = bind(this.method_factory, this);
      this.StartTransaction = bind(this.StartTransaction, this);
      var _log2;
      this.E = kit.services.error;
      _log2 = pool_opts.level2_debug ? kit.services.logger.log : {
        debug: function() {}
      };
      this.is_db_log_on = pool_opts.level2_debug;
      this.pool = mysql.createPool(pool_opts);
      this.acquire = function(callback) {
        return this.pool.getConnection(callback);
      };
      this.Acquire = Promise.promisify(this.acquire, {
        context: this
      });
      this.release = function(conn) {
        _log2.debug('DB:SqlCore:release:', 'releasing conn');
        return conn.release();
      };
      this.destroy = function(conn) {
        _log2.debug('DB:SqlCore:destroy:', 'destroying conn');
        return conn.destroy;
      };
      this.sqlQuery = (function(_this) {
        return function(ctx, sql, args) {
          var query;
          if (_this.is_db_log_on) {
            ctx.log.debug('DB:SqlCore:sqlQuery:', sql);
          }
          if (args && _this.is_db_log_on) {
            ctx.log.debug('DB:SqlCore:args:', args);
          }
          if (ctx.conn === null) {
            throw new _this.E.DbError('DB:SQL:BAD_CONN');
          }
          query = Promise.promisify(ctx.conn.query, {
            context: ctx.conn
          });
          return Promise.resolve().bind(_this).then(function() {
            return query(sql, args);
          }).then(function(just_rows) {
            if (this.is_db_log_on) {
              ctx.log.debug('DB:SqlCore:result:', just_rows);
            }
            return just_rows;
          });
        };
      })(this);
    }

    SqlCore.prototype.StartTransaction = function(ctx) {
      var f;
      f = 'DB:SqlCore:StartTransaction';
      return Promise.resolve().bind(this).then(function() {
        return this.sqlQuery(ctx, 'SET TRANSACTION ISOLATION LEVEL SERIALIZABLE');
      }).then(function() {
        return this.sqlQuery(ctx, 'START TRANSACTION');
      }).then(function() {
        return null;
      });
    };

    SqlCore.prototype.method_factory = function(sql_mod, name) {
      var create, delete_by_id, get_collection, ident_tbl, schema, sqlQuery, table, update_by_id;
      if (!sql_mod.table) {
        throw new this.E.ServerError("DB:CORE:MOD_TABLE", "table undefined for " + name);
      }
      if (!sql_mod.schema) {
        throw new this.E.ServerError("DB:CORE:MOD_SCHEMA", "schema undefined for " + name);
      }
      table = sql_mod.table;
      ident_tbl = sql_mod.ident_tbl;
      schema = sql_mod.schema;
      sqlQuery = this.sqlQuery;
      if (schema.GetByKey) {
        sql_mod.GetByKey = (function(_this) {
          return function(ctx, key, ids, lock) {
            var f;
            f = "DB:" + name + ":GetByKey:";
            if (_this.is_db_log_on) {
              ctx.log.debug(f, key);
            }
            return Promise.resolve().bind(_this).then(function() {
              var sql;
              if (!schema.GetByKey[key]) {
                throw new this.E.DbError("DB:CORE:SCHEMA_UNDEFINED:GetByKey_" + key);
              }
              sql = "SELECT " + (schema.GetByKey[key].join(',')) + "\nFROM " + table + "\nWHERE di= 0 AND " + key + " IN (?)";
              if (lock) {
                sql += ' FOR UPDATE';
              }
              return sqlQuery(ctx, sql, [ids]);
            }).then(function(db_rows) {
              return db_rows;
            });
          };
        })(this);
      }
      if (schema.UpdateByKey) {
        sql_mod.UpdateByKey = (function(_this) {
          return function(ctx, key, ids, new_values) {
            var f, nm, val;
            f = "DB:" + name + ":UpdateByKey:";
            if (_this.is_db_log_on) {
              ctx.log.debug(f, key);
            }
            if (!schema.UpdateByKey[key]) {
              throw new _this.E.DbError("DB:CORE:SCHEMA_UNDEFINED:UpdateByKey_" + key);
            }
            for (nm in new_values) {
              val = new_values[nm];
              if (indexOf.call(schema.UpdateByKey[key], nm) < 0) {
                throw new _this.E.DbError("UPDATE_BY_KEY:COL_NOT_IN_SCHEMA", {
                  col: nm,
                  value: val
                });
              }
            }
            return Promise.resolve().bind(_this).then(function() {
              var arg, cols, sql;
              cols = [];
              arg = [];
              for (nm in new_values) {
                val = new_values[nm];
                cols.push(nm + '= ?');
                arg.push(val);
              }
              arg.push(ids);
              sql = "UPDATE " + table + " SET " + (cols.join(',')) + "\nWHERE " + key + " IN (?) AND di= 0";
              return sqlQuery(ctx, sql, arg);
            }).then(function(db_result) {
              return db_result;
            });
          };
        })(this);
      }
      if (schema.DisposeByIds) {
        sql_mod.DisposeByIds = (function(_this) {
          return function(ctx, ids) {
            var f;
            f = "DB:" + name + ":DisposeByIds:";
            if (_this.is_db_log_on) {
              ctx.log.debug(f, ids);
            }
            return Promise.resolve().bind(_this).then(function() {
              var sql;
              sql = "UPDATE " + table + " SET di= 1 WHERE id IN (?)";
              return sqlQuery(ctx, sql, [ids]);
            }).then(function(db_result) {
              return db_result;
            });
          };
        })(this);
      }
      if (schema.get_collection || schema.GetCollection) {
        get_collection = (function(_this) {
          return function(ctx) {
            var f, ref, schema_cols;
            f = "DB:" + name + ":get_collection:";
            if (_this.is_db_log_on) {
              ctx.log.debug(f);
            }
            schema_cols = (ref = schema.get_collection) != null ? ref : schema.GetCollection;
            return Promise.resolve().bind(_this).then(function() {
              var sql;
              sql = "SELECT " + (schema_cols.join(',')) + "\nFROM " + table + "\nWHERE di= 0";
              return sqlQuery(ctx, sql);
            }).then(function(db_rows) {
              return db_rows;
            });
          };
        })(this);
        sql_mod.get_collection = get_collection;
        sql_mod.GetCollection = get_collection;
      }
      if (schema.get_by_id) {
        sql_mod.get_by_id = (function(_this) {
          return function(ctx, id) {
            var f;
            f = "DB:" + name + ":get_by_id:";
            if (_this.is_db_log_on) {
              ctx.log.debug(f, id);
            }
            return Promise.resolve().bind(_this).then(function() {
              var sql;
              sql = "SELECT " + (schema.get_by_id.join(',')) + "\nFROM " + table + "\nWHERE id= ? AND di= 0";
              return sqlQuery(ctx, sql, [id]);
            }).then(function(db_rows) {
              return db_rows;
            });
          };
        })(this);
      }
      if (schema.create || schema.Create) {
        create = (function(_this) {
          return function(ctx, new_values, re_read) {
            var f, nm, ref, result, schema_cols, val;
            f = "DB:" + name + ":create:";
            if (_this.is_db_log_on) {
              ctx.log.debug(f, new_values);
            }
            schema_cols = (ref = schema.create) != null ? ref : schema.Create;
            result = false;
            for (nm in new_values) {
              val = new_values[nm];
              if (indexOf.call(schema_cols, nm) < 0) {
                throw new _this.E.DbError("DB:CORE:BAD_INSERT_COL-" + table + "-" + nm);
              }
            }
            return Promise.resolve().bind(_this).then(function() {
              var arg, cols, qs, sql;
              cols = ['cr'];
              qs = ['?'];
              arg = [null];
              for (nm in new_values) {
                val = new_values[nm];
                cols.push(nm);
                qs.push('?');
                arg.push(val);
              }
              sql = "INSERT INTO " + table + " (" + (cols.join(',')) + ") VALUES (" + (qs.join(',')) + ")";
              return sqlQuery(ctx, sql, arg);
            }).then(function(db_result) {
              var sql;
              result = db_result;
              if (db_result.affectedRows !== 1) {
                throw new this.E.DbError(f + 'NO_INSERT');
              }
              if (re_read !== true) {
                return false;
              }
              if (!schema.reread) {
                throw new this.E.ServerError(f + 'REREAD_NOT_DEFINED_IN_SCHEMA');
              }
              sql = "SELECT " + (schema.reread.join(',')) + " \nFROM " + table + " \nWHERE id= ?";
              return sqlQuery(ctx, sql, [db_result.insertId]);
            }).then(function(db_rows) {
              if (db_rows !== false) {
                if (db_rows.length !== 1) {
                  throw new this.E.NotFoundError(f + 'REREAD');
                }
                result = db_rows[0];
              }
              return result;
            });
          };
        })(this);
        sql_mod.create = create;
        sql_mod.Create = create;
      }
      if (schema.update_by_id || schema.UpdateById) {
        update_by_id = (function(_this) {
          return function(ctx, id, new_values, re_read) {
            var f, nm, ref, result, schema_cols, val;
            f = "DB:" + name + ":update_by_id:";
            if (_this.is_db_log_on) {
              ctx.log.debug(f, {
                id: id,
                new_values: new_values,
                re_read: re_read
              });
            }
            schema_cols = (ref = schema.update_by_id) != null ? ref : schema.UpdateById;
            result = false;
            for (nm in new_values) {
              val = new_values[nm];
              if (indexOf.call(schema_cols, nm) < 0) {
                throw new _this.E.DbError('Invalid ' + table + ' Update Column', {
                  col: nm,
                  value: val
                });
              }
            }
            return Promise.resolve().bind(_this).then(function() {
              var arg, cols, sql;
              cols = [];
              arg = [];
              for (nm in new_values) {
                val = new_values[nm];
                cols.push(nm + '= ?');
                arg.push(val);
              }
              arg.push(id);
              sql = "UPDATE " + table + " SET " + (cols.join(',')) + "\nWHERE id= ? AND di= 0";
              return sqlQuery(ctx, sql, arg);
            }).then(function(db_result) {
              var sql;
              result = db_result;
              if (re_read !== true) {
                return false;
              }
              if (!schema.reread) {
                throw new this.E.ServerError(f + 'REREAD_NOT_DEFINED_IN_SCHEMA');
              }
              sql = "SELECT " + (schema.reread.join(',')) + "\nFROM " + table + "\nWHERE id= ?";
              return sqlQuery(ctx, sql, [id]);
            }).then(function(db_rows) {
              if (db_rows !== false) {
                if (db_rows.length !== 1) {
                  throw new this.E.NotFoundError(f + 'REREAD');
                }
                result = db_rows[0];
              }
              return result;
            });
          };
        })(this);
        sql_mod.update_by_id = update_by_id;
        sql_mod.UpdateById = update_by_id;
      }
      if (schema.delete_by_id || schema.DeleteById) {
        delete_by_id = (function(_this) {
          return function(ctx, id) {
            var sql;
            sql = "DELETE FROM " + table + "\nWHERE id= ?";
            return (sqlQuery(ctx, sql, [id])).then(function(db_result) {
              return db_result;
            });
          };
        })(this);
        sql_mod.delete_by_id = delete_by_id;
        return sql_mod.DeleteById = delete_by_id;
      }
    };

    return SqlCore;

  })();

  exports.SqlCore = SqlCore;

}).call(this);
