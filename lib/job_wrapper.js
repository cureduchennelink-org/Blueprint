// Generated by CoffeeScript 2.5.1
// Wrapper for RunQ jobs (similar to route wrapper service, logs to lamd and auto creates db handles, etc.)
// Use:
//  (near top) {JobWrapper}= require( 'job_wrapper')
//  (in server_start) @wrapper= new JobWrapper kit
var JobWrapper, Promise, Sample, _, request_count, request_count_high, uuid;

Promise = require('bluebird');
_ = require('lodash'); // This class is a sample of how you migth use the job-wrapper class.
// FOR NOW, BOTH EXAMPLES ARE 'ALWAYS-RUNNING' EXAMPLES
// IMPORTANT: YOUR CONIG MIGHT LOOK LIKE THIS:
// heartbeat_bump:
//  service: 'Heartbeat.JobBump', type: 'singleton,reoccur-per-min'
//  unique_key: 'heartbeat_bump', priority: 300, run_at: [5, 's']

Sample = class Sample {
  constructor() {
    // On startup, initialize the wrapper class, and ensure any 'always-running' runqueue jobs exsits
    this.server_start = this.server_start.bind(this);
    this.JobNotify = this.JobNotify.bind(this);
    this.JobBump = this.JobBump.bind(this); // RunQueue job to check for any contests that need bump_state based on wall-clock

    this._JobBump = this._JobBump.bind(this);
  }

  server_start(kit) {
    // TODO BETTER WAY TO GET BOTH THESE DONE WITHOUT PUTTING THE CONNECTION BACK IN THE POOL FOR EACH ADD-JOB CALL
    return Promise.resolve().bind(this).then(function () {
      return this.wrapper = new JobWrapper(kit);
    }).then(function () {
      return this.JobBump('add_job');
    }).then(function () {
      return this.JobNotify('add_job');
    });
  }

  JobNotify(job) {
    return this.wrapper.wrap(job, '_JobNotify', this, {
      sql_conn: true,
      sql_tx: true,
      replace: true,
      // Always
      did_work: {
        run_at: [0, 's' // What to add to 'replace' when we had work to do
        ]
      },
      add_job: {
        topic: 'heartbeat_notify',
        json: '{}',
        run_at: [0, 's']
      }
    });
  }

  JobBump(job) {
    return this.wrapper.wrap(job, '_JobBump', this, {
      sql_conn: true,
      sql_tx: true,
      replace: true,
      // Always
      did_work: {
        run_at: [0, 's' // What to add to 'replace' when we had work to do
        ]
      },
      add_job: {
        topic: 'heartbeat_bump',
        json: '{}',
        run_at: [0, 's' // Intially add this job to the queue
        ]
      }
    });
  }

  _JobBump(ctx, job) {
    var contests, did_work, f, testability;
    f = 'Sample:JobBump:';
    testability = {};
    contests = false;
    did_work = false; // Tell wrapper, so it can reschdule us with proper run_at

    return Promise.resolve().bind(this).then(function () {
      // Call your DB to look for work
      return this.sdb.contest.GetForBump(ctx, where_map);
    }).then(function (db_rows) {
      var bump_results, c, i, len, q_chain;
      contests = db_rows;

      testability.contests = function () {
        var i, len, results;
        results = [];

        for (i = 0, len = contests.length; i < len; i++) {
          c = contests[i];
          results.push(c.id);
        }

        return results;
      }(); // IMPORTANT: Mark if you job did any work or now (later used for filter in Health filter endpoints)


      did_work = contests.length > 0;

      if (did_work === false) {
        // Bump them all in this transaction, so JobNotify will send only 1 push for multiple contests starting at once
        // IMPORTANT: EXAMPLE OF HAVING NOTHING TO DO, AND EXPECT TO BE SCHEDULED AGAIN PER THE RETRY SETTINGS IN '@JobBump'
        return {
          did_work
        };
      }

      bump_results = []; // Accumulate results from all calls

      q_chain = Promise.resolve().bind(this);

      for (i = 0, len = contests.length; i < len; i++) {
        c = contests[i];

        (c => {
          return q_chain = q_chain.then(function () {
            return this.bump_state(ctx, c); // Smart enough to update the contest record for us (and set 'pause')
          }).then(function (result) {
            return bump_results.push(result);
          });
        })(c);
      }

      return q_chain.then(function () {
        return bump_results;
      });
    }).then(function (result) {
      var c, filter; // HELPFUL: ST A TESTABILITY VALUE FOR THE AUTOMATED TESTS

      testability.bump_result = result; // HELPFUL: USE A FILTER VALUE FOR HEALTH ENDPOINTS FILTER (TODO)

      filter = did_work ? {
        contest: {
          ids: function () {
            var i, len, results;
            results = [];

            for (i = 0, len = contests.length; i < len; i++) {
              c = contests[i];
              results.push(c.id);
            }

            return results;
          }()
        }
      } : null;
      return {
        did_work,
        testability,
        filter
      };
    });
  }

};
uuid = require('uuid');
request_count = {
  all: 0
};
request_count_high = {
  all: 0
}; // LAMD is not required, and is stubbed if the service was not found

JobWrapper = class JobWrapper {
  constructor(kit) {
    var ref, stubb_lamd; // TODO ADD LAMD OBJECT AND WRITE IT ALSO; ADD LAMD DEBUG TO CTX LOG
    // TODO AUTH_ID MAYBE SET IN JOB DESCRIPTION

    this.wrap = this.wrap.bind(this);
    this.E = kit.services.error;
    this.log = kit.services.logger.log;
    this.sdb = kit.services.db.psql;
    this.runqueue = kit.services.RunQueue;
    stubb_lamd = {
      GetLog: ctx => {
        return this.log; // console
      },
      write: function (lamd) {
        return console.log(lamd);
      },
      write_deep: function (ctx) {
        return console.log('stubb_lamd::write_deep');
      }
    };
    this.lamd = (ref = kit.services.lamd) != null ? ref : stubb_lamd; // You would need to add this service in your start-up script
  } // Works for PSQL at this time, because the core has a method for it


  _check_db_connection(c) {
    var err_values;
    err_values = this.sdb.core._checkConn(c); // Returns true if ok, else error values

    if (err_values !== true) {
      throw new this.E.ServerError(f + 'BadHandle:' + JSON.stringify(exposeErrorProperties(err_values)));
    }
  }

  start_connection_limit(topic) {
    var cnt; // By topic

    if (request_count[topic] == null) {
      request_count[topic] = 0;
    }

    cnt = ++request_count[topic];

    if (request_count_high[topic] < cnt) {
      request_count_high[topic] = cnt;
    } // For all


    cnt = ++request_count.all;

    if (request_count_high.all < cnt) {
      return request_count_high.all = cnt;
    }
  }

  end_connection_limit(topic) {
    var cnt; // By topic

    cnt = --request_count[topic];

    if (cnt < 1) {
      delete request_count[topic];
    }

    if (request_count.all) {
      // For all
      return request_count.all--;
    }
  }

  wrap(job, job_name, job_class, options) {
    var _wrapper_add_job, _wrapper_run_job, ctx, default_tx, f, is_add_request, opts, ref, req, result;

    f = 'JobWrapper.wrap:' + job_name;
    req = {
      log: this.log // For fatal errors in rollback

    };
    is_add_request = job === 'add_job'; // Request to add the job initially

    if (is_add_request) {
      if (typeof ((ref = options.add_job) != null ? ref.topic : void 0) !== 'string') {
        throw new this.E.ServerError('NO ADD_JOB IN OPTIONS:' + job_name);
      }
    } // ORIG default_tx= if is_add_request then on else off # XXX


    default_tx = is_add_request ? false : false; // XXX

    opts = _.merge({
      sql_conn: default_tx,
      sql_tx: default_tx,
      replace: false,
      did_work: {},
      success: true
    }, options);
    ctx = {
      conn: null,
      lamd: {
        start: Date.now(),
        date: new Date().toJSON(),
        // Timestamps
        job_name,
        job,
        did_work: 'not-set',
        opts,
        req_uuid: 'J' + uuid.v4(),
        auth_id: 98,
        // Filters
        conn_id: 0 // Debugging

      }
    };
    ctx.log = this.lamd.GetLog(ctx); // Potentially overwrite Bunyan with lamd.debug loggin

    ctx.log.debug(f, {
      job_name,
      options,
      is_add_request,
      default_tx,
      opts,
      job
    });
    result = false; // Should be populated by the job; this is returned to the runqueue system

    _wrapper_add_job = () => {
      ctx.lamd.did_work = 'add-job';
      return Promise.resolve().bind(this).then(function () {
        return this.runqueue.AddJob(ctx, opts.add_job);
      }).then(() => {
        return true;
      }).catch(e => {
        if (e.name === this.runqueue.ERR_DUPLICATE_JOB || e.code === '23505') {
          // Allow failure of unique key duplicate
          return false;
        }

        throw e;
      });
    };

    _wrapper_run_job = () => {
      var rObj;
      ctx.lamd.did_work = 'run-job';
      rObj = {
        success: false
      };
      return Promise.resolve().bind(this).then(function () {
        return job_class[job_name](ctx, job);
      }).then(function (job_result) {
        var ref1, ref2, replace; // When not throwing an error, caller can still set success:false and control the 'replace' object (updated json, run_at, etc)

        if (job_result.replace === true || opts.replace === true) {
          // Return a 'replace' object to the job system
          replace = {
            unique_key: job.unique_key,
            // System requires this
            json: (ref1 = job_result.json) != null ? ref1 : job.json // System always wants the, so dup from original if not supplied by caller

          };

          if (job_result.did_work === true) {
            // Request to run again right away
            _.merge(replace, opts.did_work);
          }

          rObj.replace = replace;
        }

        _.merge(rObj, _.pick(job_result, ['testability', 'did_work', 'filter', 'reason']));

        return (ref2 = job_result.success) != null ? ref2 : opts.success; // Default to all-good
      }).then(function (success) {
        var ref1;
        rObj.success = success; // Propogate success value (assume all is well if not set and not thrown an error)

        ctx.lamd.did_work = (ref1 = rObj.did_work) != null ? ref1 : 'run:missing:' + success;
        return rObj;
      });
    };

    return Promise.resolve().bind(this).then(function () {
      this.start_connection_limit(job.topic); // Keep this below any logic that might return before end_* is called

      ctx.lamd.request_count = request_count;
      ctx.lamd.request_count_high = request_count_high; // Acquire DB Connection
      // TODO CHECK TO SEE IF CONN IS BEING REQUESTED IN OPTS

      return this.sdb.core.Acquire();
    }).then(function (c) {
      if (c !== false) {
        ctx.conn = c;
        ctx.lamd.conn_id = c.__pool_id;
      }

      this._check_db_connection(ctx.conn); //throw new @E.ServerError f + 'BadHandle:' + JSON.stringify @_exposeErrorProperties ctx.conn._protocol._fatalError if ctx.conn isnt null and ctx.conn._protocol._fatalError isnt null
      // Start a Transaction
      // TODO OPTIONAL IN OPTS


      return this.sdb.core.StartTransaction(ctx);
    }).then(function () {
      // Call the JOB/ADD_JOB Logic
      if (is_add_request === true) {
        return _wrapper_add_job();
      } else {
        return _wrapper_run_job();
      }
    }).then(function (result_hash) {
      ctx.lamd.result = result = result_hash;

      this._check_db_connection(ctx.conn); //throw new @E.ServerError f + 'BadHandle:' + JSON.stringify @_exposeErrorProperties ctx.conn._protocol._fatalError if ctx.conn isnt null and ctx.conn._protocol._fatalError isnt null
      // Commit the transaction


      return this.sdb.core.sqlQuery(ctx, 'COMMIT');
    }).then(function (db_result) {
      if (ctx.conn !== null) {
        // Release database conn; Respond to Client
        this.sdb.core.release(ctx.conn);
      }

      ctx.lamd.duration = Date.now() - ctx.lamd.start;
      this.lamd.write(ctx.lamd);
      this.lamd.write_deep(ctx); // TODO CHECK CONFIG IF WE WANT ALL POSSIBLE ERRORS TO WRITE TO DEEP LOG

      this.end_connection_limit(job.topic);
      return result;
    }).catch(function (err) {
      var e;
      ctx.log.error(f + '.catch', {
        err: this._exposeErrorProperties(err),
        stack: err.stack
      });

      if (ctx.conn !== null) {
        ctx.conn.query('ROLLBACK', err => {
          if (err) {
            ctx.log.warn(f, {
              note: 'destroy db conn (failed rollback)'
            });
            this.sdb.core.destroy(ctx.conn);
            return ctx.log.error(f + '.catch', {
              stack: err.stack
            });
          } else {
            ctx.log.debug(f, {
              note: 'release db conn (successful rollback)'
            });
            return this.sdb.core.release(ctx.conn);
          }
        });
      } // DON'T LIKE HOW THIS HIDES REAL ERRORS: e= if err.body then err else new @E.ServerError err.name, err.message


      e = err;

      if (!e.body) {
        e.body = {};
      }

      e.body.req_uuid = ctx.lamd.req_uuid;
      ctx.lamd.duration = Date.now() - ctx.lamd.start;
      ctx.lamd.err = this._exposeErrorProperties(err);
      this.lamd.write(ctx.lamd);
      this.lamd.write_deep(ctx); // TODO CHECK CONFIG IF WE WANT ALL POSSIBLE ERRORS TO WRITE TO DEEP LOG

      this.end_connection_limit(job.topic);

      e.toJSON = () => {
        return this._exposeErrorProperties(e); // WHY NOT THE WHOLE ERROR? .body
      };

      throw e;
    });
  } // https://www.bennadel.com/blog/3278-using-json-stringify-replacer-function-to-recursively-serialize-and-sanitize-log-data.htm


  _exposeErrorProperties(error) {
    var copy;
    copy = Object.assign({}, error);

    if (error.name) {
      // In the native Error class (and any class that extends Error), the
      // following properties are not "enumerable". As such, they won't be copied by
      // the Object.assign() call above. In order to make sure that they are included
      // in the serialization process, we have to copy them manually.
      copy.name = error.name;
    }

    if (error.message) {
      copy.message = error.message;
    } //copy.stack= error.stack if error.stack


    return copy;
  }

};
exports.JobWrapper = JobWrapper;