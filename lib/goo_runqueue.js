// Generated by CoffeeScript 1.9.2
(function() {
  var Promise, RunQueueMongoDbPersistence, RunQueueMongoDbSchema, _, logRequest, logResponse, mongoose, testing;

  _ = require('lodash');

  Promise = require('bluebird');

  mongoose = require('mongoose');

  mongoose.Promise = Promise;

  RunQueueMongoDbSchema = require('./goo_schema_runqueue');

  testing = process.env.DB_DEBUG_LEVEL2 === 'true';

  logRequest = function() {};

  logResponse = function() {};

  if (testing) {
    logRequest = function(f, obj) {
      return console.log("##### QUERY >>>" + f, obj);
    };
    logResponse = function(f, objs) {
      var i, len, obj, results1;
      if (!Array.isArray(objs)) {
        objs = [objs];
      }
      console.log("##### RESP >>> " + f, {
        length: objs.length
      });
      results1 = [];
      for (i = 0, len = objs.length; i < len; i++) {
        obj = objs[i];
        if ((obj != null ? obj.toJSON : void 0) != null) {
          results1.push(console.log(" -#- ", obj.toJSON()));
        } else {
          results1.push(void 0);
        }
      }
      return results1;
    };
  }

  RunQueueMongoDbPersistence = (function() {
    RunQueueMongoDbPersistence.deps = {};

    function RunQueueMongoDbPersistence() {
      this._schema = new RunQueueMongoDbSchema();
    }

    RunQueueMongoDbPersistence.prototype.open = function(uri, db_name) {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          return mongoose.connect(uri, function(err) {
            var mydb;
            if (err) {
              reject(err);
            }
            _this._connection = mongoose.connection;
            mydb = mongoose.connection.useDb(db_name);
            _this._model = mydb.model('RunQueue', _this._schema);
            return resolve();
          });
        };
      })(this));
    };

    RunQueueMongoDbPersistence.prototype.close = function() {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          if (_this._model === null) {
            return resolve();
          }
          return mongoose.disconnect(function(err) {
            _this._model = null;
            if (err) {
              return reject(err);
            } else {
              return resolve();
            }
          });
        };
      })(this));
    };

    RunQueueMongoDbPersistence.prototype.GetJobById = function(ctx, id) {
      return this._model.findById(id);
    };

    RunQueueMongoDbPersistence.prototype.GetPendingCnts = function(ctx) {
      var f, pipeline;
      f = "RunQueueMongoDbPersistence::GetPendingCnts: ";
      pipeline = [
        {
          $match: {
            in_process: 1,
            di: 0
          }
        }, {
          $group: {
            _id: '$group_ref',
            count: {
              $sum: 1
            }
          }
        }
      ];
      logRequest(f, {
        pipeline: pipeline
      });
      return this._model.aggregate(pipeline).then(function(results) {
        var i, len, r, results1;
        logResponse(f, results);
        results1 = [];
        for (i = 0, len = results.length; i < len; i++) {
          r = results[i];
          results1.push({
            group_ref: r._id,
            active_cnt: r.count
          });
        }
        return results1;
      });
    };

    RunQueueMongoDbPersistence.prototype.GetNextJobs = function(ctx, maxRows, maxRetries) {
      var conditions, date, f, oneSLess;
      if (maxRetries == null) {
        maxRetries = 8;
      }
      f = "RunQueueMongoDbPersistence::GetNextJobs: ";
      date = new Date();
      oneSLess = new Date(date - 1000);
      conditions = {
        in_process: 0,
        run_at: {
          $lte: oneSLess
        },
        retries: {
          $lte: maxRetries
        },
        di: 0
      };
      logRequest(f, {
        conditions: conditions,
        maxRows: maxRows
      });
      return this._model.find(conditions).sort({
        priority: 1,
        run_at: 1
      }).limit(maxRows).then(function(model_result) {
        var i, len, model, results1;
        logResponse(f, model_result);
        results1 = [];
        for (i = 0, len = model_result.length; i < len; i++) {
          model = model_result[i];
          results1.push(model.toJSON());
        }
        return results1;
      });
    };

    RunQueueMongoDbPersistence.prototype.AddJob = function(ctx, newValues, reread) {
      var f, options;
      if (reread == null) {
        reread = false;
      }
      f = 'RunQueueMongoDbPersistence::AddJob:';
      newValues = _.pick(newValues, 'unique_key', 'topic', 'group_ref', 'priority', 'run_at', 'json');
      _.merge(newValues, {
        mo: new Date(),
        in_process: 0,
        retries: 0
      });
      newValues.in_process = 0;
      options = {};
      logRequest(f, {
        newValues: newValues,
        options: options
      });
      return new this._model(newValues).save(options).then(function(model_result) {
        logResponse(f, model_result);
        if (reread) {
          return [model_result.toJSON()];
        } else {
          return {
            affectedRows: 1,
            insertId: model_result.toJSON().id
          };
        }
      });
    };

    RunQueueMongoDbPersistence.prototype.ReplaceJob = function(ctx, id, newValues, reread) {
      var defaults, doc, f, i, len, nm, options, ref, unset;
      if (reread == null) {
        reread = false;
      }
      f = 'RunQueueMongoDbPersistence::ReplaceJob:';
      newValues = _.pick(newValues, 'unique_key', 'priority', 'run_at', 'json');
      defaults = {
        in_process: 0,
        retries: 0
      };
      newValues = _.merge({}, defaults, newValues);
      newValues.mo = new Date();
      unset = {};
      ref = ['fail_at', 'last_reason', 'unique_key', 'json'];
      for (i = 0, len = ref.length; i < len; i++) {
        nm = ref[i];
        if (!(nm in newValues)) {
          unset[nm] = '';
        }
      }
      doc = {
        $set: newValues,
        $unset: unset
      };
      options = {
        "new": true,
        rawResult: true
      };
      logRequest(f, {
        id: id,
        doc: doc,
        options: options
      });
      return this._model.findByIdAndUpdate(id, doc, options).then(function(mongo_result) {
        var ref1;
        logResponse(f, mongo_result);
        if (mongo_result && ((ref1 = mongo_result.lastErrorObject) != null ? ref1.n : void 0) === 1) {
          if (reread) {
            return [mongo_result.value.toJSON()];
          } else {
            return {
              affectedRows: 1
            };
          }
        } else {
          if (reread) {
            return [];
          } else {
            return {
              affectedRows: 0
            };
          }
        }
      });
    };

    RunQueueMongoDbPersistence.prototype.MarkJobPending = function(ctx, id, otherValues, reread) {
      var conditions, doc, f, newValues, options;
      if (reread == null) {
        reread = false;
      }
      f = 'RunQueueMongoDbPersistence::MarkJobPending:';
      newValues = otherValues != null ? otherValues : {};
      newValues = _.pick(newValues, 'unique_key', 'priority', 'run_at', 'json', 'fail_at');
      newValues.mo = new Date();
      newValues.in_process = 1;
      conditions = {
        _id: id,
        in_process: 0
      };
      doc = {
        $set: newValues
      };
      options = {
        "new": true,
        rawResult: true
      };
      logRequest(f, {
        conditions: conditions,
        doc: doc,
        options: options
      });
      return this._model.findOneAndUpdate(conditions, doc, options).then(function(mongo_result) {
        var ref;
        logResponse(f, mongo_result);
        if (mongo_result && ((ref = mongo_result.lastErrorObject) != null ? ref.n : void 0) === 1) {
          if (reread) {
            return [mongo_result.value.toJSON()];
          } else {
            return {
              affectedRows: 1
            };
          }
        } else {
          if (reread) {
            return [];
          } else {
            return {
              affectedRows: 0
            };
          }
        }
      });
    };

    RunQueueMongoDbPersistence.prototype.Fail = function(ctx, id, newValues, reread) {
      var doc, f, options;
      if (reread == null) {
        reread = false;
      }
      f = 'RunQueueMongoDbPersistence::Fail:';
      newValues = _.pick(newValues, 'last_reason', 'run_at');
      newValues.mo = new Date();
      newValues.in_process = 0;
      doc = {
        $set: newValues,
        $inc: {
          retries: 1
        },
        $unset: {
          fail_at: ''
        }
      };
      options = {
        "new": true,
        rawResult: true
      };
      logRequest(f, {
        id: id,
        doc: doc,
        options: options
      });
      return this._model.findByIdAndUpdate(id, doc, options).then(function(mongo_result) {
        var ref;
        logResponse(f, mongo_result);
        if (mongo_result && ((ref = mongo_result.lastErrorObject) != null ? ref.n : void 0) === 1) {
          if (reread) {
            return [mongo_result.value.toJSON()];
          } else {
            return {
              affectedRows: 1
            };
          }
        } else {
          if (reread) {
            return [];
          } else {
            return {
              affectedRows: 0
            };
          }
        }
      });
    };

    RunQueueMongoDbPersistence.prototype.RemoveByIds = function(ctx, ids) {
      var conditions, doc, f;
      f = 'RunQueueMongoDbPersistence::RemoveByIds:';
      if (!_.isArray(ids)) {
        ids = [ids];
      }
      conditions = {
        _id: {
          $in: ids
        }
      };
      doc = {
        $set: {
          mo: new Date(),
          di: 1
        }
      };
      logRequest(f, {
        conditions: conditions,
        doc: doc
      });
      return this._model.updateMany(conditions, doc).then(function(result) {
        logResponse(f, result);
        return {
          affectedRows: result.nModified
        };
      });
    };

    RunQueueMongoDbPersistence.prototype.RemoveByUniqueKeys = function(ctx, uniqueKeys) {
      var conditions, doc, f;
      f = 'RunQueueMongoDbPersistence::RemoveByUniqueKeys:';
      if (!_.isArray(uniqueKeys)) {
        uniqueKeys = [uniqueKeys];
      }
      conditions = {
        unique_key: {
          $in: uniqueKeys
        }
      };
      doc = {
        $set: {
          mo: new Date(),
          di: 1
        }
      };
      logRequest(f, {
        conditions: conditions,
        doc: doc
      });
      return this._model.updateMany(conditions, doc).then(function(result) {
        logResponse(f, result);
        return {
          affectedRows: result.nModified
        };
      });
    };

    RunQueueMongoDbPersistence.prototype.GetDelayedByTopic = function(ctx) {
      var f, pipeline;
      f = 'RunQueueMongoDbPersistence::GetDelayedByTopic:';
      pipeline = [
        {
          $match: {
            di: 0,
            in_process: 0,
            run_at: {
              $lte: new Date()
            }
          }
        }, {
          $group: {
            _id: "$topic",
            run_at: {
              $min: '$run_at'
            }
          }
        }, {
          $addFields: {
            delay: {
              $subtract: [new Date(), "$run_at"]
            }
          }
        }
      ];
      logRequest(f, {
        pipeline: pipeline
      });
      return this._model.aggregate(pipeline).then(function(results) {
        var i, len, r, results1;
        logResponse(f, results);
        results1 = [];
        for (i = 0, len = results.length; i < len; i++) {
          r = results[i];
          results1.push({
            topic: r._id,
            delay: Math.floor(r.delay / 1000)
          });
        }
        return results1;
      });
    };

    RunQueueMongoDbPersistence.prototype.GetRetriesByTopic = function(ctx) {
      var f, pipeline;
      f = 'RunQueueMongoDbPersistence::GetRetriesByTopic:';
      pipeline = [
        {
          $match: {
            di: 0,
            retries: {
              $gt: 0
            }
          }
        }, {
          $group: {
            _id: "$topic",
            max_retries: {
              $max: '$retries'
            }
          }
        }
      ];
      logRequest(f, {
        pipeline: pipeline
      });
      return this._model.aggregate(pipeline).then(function(results) {
        var i, len, r, results1;
        logResponse(f, results);
        results1 = [];
        for (i = 0, len = results.length; i < len; i++) {
          r = results[i];
          results1.push({
            topic: r._id,
            max_retries: r.max_retries
          });
        }
        return results1;
      });
    };

    RunQueueMongoDbPersistence.prototype.GetFailuresByTopic = function(ctx) {
      var f, pipeline;
      f = 'RunQueueMongoDbPersistence::GetFailuresByTopic:';
      pipeline = [
        {
          $match: {
            di: 0,
            in_process: 1,
            fail_at: {
              $lte: new Date()
            }
          }
        }, {
          $group: {
            _id: "$topic",
            failures: {
              $sum: 1
            }
          }
        }
      ];
      logRequest(f, {
        pipeline: pipeline
      });
      return this._model.aggregate(pipeline).then(function(results) {
        var i, len, r, results1;
        logResponse(f, results);
        results1 = [];
        for (i = 0, len = results.length; i < len; i++) {
          r = results[i];
          results1.push({
            topic: r._id,
            failures: r.failures
          });
        }
        return results1;
      });
    };

    return RunQueueMongoDbPersistence;

  })();

  module.exports = RunQueueMongoDbPersistence;

}).call(this);
