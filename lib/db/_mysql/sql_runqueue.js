// Generated by CoffeeScript 1.9.2
(function() {
  var Promise, SqlRunQueue, _, it_is,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Promise = require('bluebird');

  _ = require('lodash');

  it_is = require('is_js');

  SqlRunQueue = (function() {
    function SqlRunQueue(core, kit) {
      var cols;
      this.log = kit.services.logger.log;
      this.E = kit.services.error;
      this.db = core;
      this.table = 'runqueue';
      cols = ['id', 'di', 'cr', 'mo', 'unique_key', 'topic', 'group_ref', 'in_process', 'priority', 'run_at', 'retries', 'fail_at', 'last_reason', 'json'];
      this.schema = {
        AddJob: {
          allowed: ['unique_key', 'topic', 'group_ref', 'priority', 'run_at', 'json'],
          defaults: {
            in_process: 0,
            retries: 0,
            fail_at: null,
            last_reason: null
          }
        },
        ReplaceJob: {
          allowed: ['unique_key', 'priority', 'run_at', 'json'],
          defaults: {
            in_process: 0,
            retries: 0,
            fail_at: null,
            last_reason: null,
            unique_key: null,
            json: null
          }
        },
        Fail: {
          required: ['last_reason', 'run_at'],
          defaults: {
            in_process: 0,
            fail_at: null
          }
        }
      };
      this.db.method_factory(this, 'SqlRunQueue');
    }

    SqlRunQueue.prototype.GetPendingCnts = function(ctx) {
      var f, sql;
      f = "SqlRunQueue:GetPendingCnts:";
      sql = "SELECT COUNT(*) active_cnt, group_ref\nFROM " + this.table + "\nWHERE in_process= 1 AND di= 0\nGROUP BY group_ref";
      return Promise.resolve().bind(this).then(function() {
        return this.db.sqlQuery(ctx, sql, []);
      });
    };

    SqlRunQueue.prototype.GetNextJobs = function(ctx, max_rows, max_retries) {
      var f, sql;
      if (max_retries == null) {
        max_retries = 8;
      }
      f = "SqlRunQueue:GetNextJobs:";
      sql = "SELECT *\nFROM " + this.table + "\nWHERE in_process= 0 AND run_at< NOW() AND retries< ? AND di= 0\nORDER BY priority, run_at\nLIMIT ?";
      return Promise.resolve().bind(this).then(function() {
        return this.db.sqlQuery(ctx, sql, [max_retries, max_rows]);
      });
    };

    SqlRunQueue.prototype.MarkJobPending = function(ctx, id, other_values, reread) {
      var args, f, nm, sets, sql, val;
      if (reread == null) {
        reread = false;
      }
      f = "SqlRunQueue:MarkJobPending:";
      sets = ['in_process= ?'];
      args = [1];
      for (nm in other_values) {
        val = other_values[nm];
        sets.push(nm + "= ?");
        args.push(val);
      }
      args.push(id);
      sql = "UPDATE " + this.table + "\nSET " + (sets.join(',')) + "\nWHERE id= ? AND in_process= 0";
      return Promise.resolve().bind(this).then(function() {
        return this.db.sqlQuery(ctx, sql, args);
      }).then(function(db_result) {
        if (reread !== true) {
          return db_result;
        }
        if (db_result.affectedRows !== 1) {
          return [];
        }
        return this.db.sqlQuery(ctx, "SELECT * FROM " + this.table + " WHERE ID= ?", [id]);
      });
    };

    SqlRunQueue.prototype.RemoveByIds = function(ctx, ids) {
      var f, sql;
      f = "SqlRunQueue:RemoveByIds:";
      if (!it_is.array(ids)) {
        ids = [ids];
      }
      sql = "UPDATE " + this.table + "\nSET di= 1\nWHERE id IN (?)";
      return Promise.resolve().bind(this).then(function() {
        return this.db.sqlQuery(ctx, sql, [ids]);
      });
    };

    SqlRunQueue.prototype.RemoveByUniqueIds = function(ctx, uniqueIds) {
      var f, sql;
      f = "SqlRunQueue:RemoveByUniqueIds:";
      if (!it_is.array(uniqueIds)) {
        uniqueIds = [ids];
      }
      sql = "UPDATE " + this.table + "\nSET di= 1\nWHERE unique_id IN (?)";
      return Promise.resolve().bind(this).then(function() {
        return this.db.sqlQuery(ctx, sql, uniqueIds);
      });
    };

    SqlRunQueue.prototype.AddJob = function(ctx, new_values, reread) {
      var allowed_values, args, cols, e, f, nm, sql, val, vals, values;
      if (reread == null) {
        reread = false;
      }
      f = "SqlRunQueue:AddJob:";
      e = f;
      allowed_values = {};
      for (nm in new_values) {
        val = new_values[nm];
        if (indexOf.call(this.schema.AddJob.allowed, nm) < 0) {
          throw new this.E.DbError(e + ("UNKNOWN_COL:" + nm));
        }
        allowed_values[nm] = val;
      }
      values = _.merge({}, this.schema.AddJob.defaults, allowed_values);
      cols = ['cr'];
      vals = ['?'];
      args = [null];
      for (nm in values) {
        val = values[nm];
        cols.push(nm);
        vals.push('?');
        args.push(val);
      }
      sql = "INSERT INTO " + this.table + " ( " + cols + " ) VALUES ( " + vals + " )";
      return Promise.resolve().bind(this).then(function() {
        return this.db.sqlQuery(ctx, sql, args);
      }).then(function(db_result) {
        var id;
        if (reread !== true) {
          return db_result;
        }
        if (db_result.affectedRows !== 1) {
          return [];
        }
        id = db_result.insertId;
        return this.db.sqlQuery(ctx, "SELECT * FROM " + this.table + " WHERE ID= ?", [id]);
      });
    };

    SqlRunQueue.prototype.ReplaceJob = function(ctx, id, new_values, reread) {
      var allowed_values, args, e, f, nm, sets, sql, val, values;
      if (reread == null) {
        reread = false;
      }
      f = "SqlRunQueue:AddJob:";
      e = f;
      allowed_values = {};
      for (nm in new_values) {
        val = new_values[nm];
        if (indexOf.call(this.schema.ReplaceJob.allowed, nm) < 0) {
          throw new this.E.DbError(e + ("UNKNOWN_COL:" + nm));
        }
        allowed_values[nm] = val;
      }
      values = _.merge({}, this.schema.ReplaceJob.defaults, allowed_values);
      sets = [];
      args = [];
      for (nm in values) {
        val = values[nm];
        sets.push(nm + "=?");
        args.push(val);
      }
      args.push(id);
      sql = "UPDATE " + this.table + "\nSET " + sets + "\nWHERE ID= ?";
      return Promise.resolve().bind(this).then(function() {
        return this.db.sqlQuery(ctx, sql, args);
      }).then(function(db_result) {
        if (reread !== true) {
          return db_result;
        }
        if (db_result.affectedRows !== 1) {
          return [];
        }
        return this.db.sqlQuery(ctx, "SELECT * FROM " + this.table + " WHERE ID= ?", [id]);
      });
    };

    SqlRunQueue.prototype.Fail = function(ctx, id, new_values, reread) {
      var allowed_values, args, e, f, i, len, nm, ref, sets, sql, val, values;
      if (reread == null) {
        reread = false;
      }
      f = "SqlRunQueue:Fail:";
      e = f;
      allowed_values = {};
      for (nm in new_values) {
        val = new_values[nm];
        if (indexOf.call(this.schema.Fail.required, nm) < 0) {
          throw new this.E.DbError(e + ("UNKNOWN_COL:" + nm));
        }
      }
      ref = this.schema.Fail.required;
      for (i = 0, len = ref.length; i < len; i++) {
        nm = ref[i];
        if (!(nm in new_values)) {
          throw new this.E.DbError(e + ("MISSING_COL:" + nm));
        }
        allowed_values[nm] = new_values[nm];
      }
      values = _.merge({}, this.schema.Fail.defaults, allowed_values);
      sets = ['retries= retries+ 1'];
      args = [];
      for (nm in values) {
        val = values[nm];
        sets.push(nm + "=?");
        args.push(val);
      }
      args.push(id);
      sql = "UPDATE " + this.table + "\nSET " + sets + "\nWHERE ID= ?";
      return Promise.resolve().bind(this).then(function() {
        return this.db.sqlQuery(ctx, sql, args);
      }).then(function(db_result) {
        if (reread !== true) {
          return db_result;
        }
        if (db_result.affectedRows !== 1) {
          return [];
        }
        return this.db.sqlQuery(ctx, "SELECT * FROM " + this.table + " WHERE ID= ?", [id]);
      });
    };

    SqlRunQueue.prototype.GetDelayedByTopic = function(ctx) {
      var f, sql;
      f = "SqlRunQueue:GetDelayedByTopic:";
      sql = "SELECT topic, TIMESTAMPDIFF(SECOND,MIN(run_at), NOW()) AS 'delay'\nFROM " + this.table + "\nWHERE run_at < NOW() and di = 0 and in_process = 0\nGROUP BY topic";
      return Promise.resolve().bind(this).then(function() {
        return this.db.sqlQuery(ctx, sql, []);
      });
    };

    SqlRunQueue.prototype.GetRetriesByTopic = function(ctx) {
      var f, sql;
      f = "SqlRunQueue:GetRetriesByTopic:";
      sql = "SELECT topic, MAX(retries) AS 'max_retries'\nFROM " + this.table + "\nWHERE di = 0 and retries > 0\nGROUP BY topic";
      return Promise.resolve().bind(this).then(function() {
        return this.db.sqlQuery(ctx, sql, []);
      });
    };

    SqlRunQueue.prototype.GetFailuresByTopic = function(ctx) {
      var f, sql;
      f = "SqlRunQueue:GetFailuresByTopic:";
      sql = "SELECT topic, COUNT(*) AS 'failures'\nFROM " + this.table + "\nWHERE di = 0 and in_process = 1 and fail_at < NOW()\nGROUP BY topic";
      return Promise.resolve().bind(this).then(function() {
        return this.db.sqlQuery(ctx, sql, []);
      });
    };

    return SqlRunQueue;

  })();

  exports.SqlRunQueue = SqlRunQueue;

}).call(this);
