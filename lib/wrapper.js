// Generated by CoffeeScript 1.9.2
(function() {
  var Promise, Wrapper, request_count, request_count_high,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Promise = require('bluebird');

  request_count = 0;

  request_count_high = 0;

  Wrapper = (function() {
    Wrapper.deps = {
      mysql: ['core'],
      mongo: ['pool'],
      services: ['router', 'lamd', 'error', 'auth'],
      config: 'throttling.max_connections,db.mysql.enable,auth.bearer,perf?.test_user_override'
    };

    function Wrapper(kit) {
      this["default"] = bind(this["default"], this);
      this.auth = bind(this.auth, this);
      this.add = bind(this.add, this);
      this.add_wrap = bind(this.add_wrap, this);
      this.config = kit.services.config;
      this.E = kit.services.error;
      this.odb = kit.services.db.mongo;
      this.sdb = kit.services.db.mysql;
      this.router = kit.services.router;
      this.lamd = kit.services.lamd;
      this.routes = kit.routes;
      this.wraps = {};
    }

    Wrapper.prototype.start_connection_limit = function() {
      if (this.config.throttling.max_connections && request_count > this.config.throttling.max_connections) {
        throw new this.E.TooManyConnectionsError("Max:" + this.config.throttling.max_connections + ", Count:" + request_count);
      }
      request_count++;
      if (request_count_high < request_count) {
        return request_count_high = request_count;
      }
    };

    Wrapper.prototype.end_connection_limit = function() {
      if (request_count) {
        return request_count--;
      }
    };

    Wrapper.prototype.add_wrap = function(mod, wrap) {
      return this.wraps[mod] = wrap;
    };

    Wrapper.prototype.add = function(mod) {
      var endpoint, f, func, ref, results, wrap;
      f = 'Wrapper:add:';
      if (mod in this.wraps) {
        return this.wraps[mod](mod);
      }
      ref = this.routes[mod].endpoints;
      results = [];
      for (func in ref) {
        endpoint = ref[func];
        endpoint.name = mod + ':' + func;
        wrap = this[endpoint.wrap](endpoint);
        results.push(this.router.AddRoute(mod, func, endpoint.verb, endpoint.route, wrap));
      }
      return results;
    };

    Wrapper.prototype.auth_wrap = function(caller) {
      var auth_func;
      auth_func = this.auth;
      return function(q, s, n) {
        return auth_func(q, s, n, caller);
      };
    };

    Wrapper.prototype.default_wrap = function(caller) {
      var func;
      func = this['default'];
      return function(q, s, n) {
        return func(q, s, n, caller);
      };
    };

    Wrapper.prototype.simple_wrap = function(caller) {
      var func;
      func = this.simple;
      return function(q, s, n) {
        return func(q, s, n, caller);
      };
    };

    Wrapper.prototype.simple = function(req, res, next, caller) {
      var f, ref, ref1, route_logic;
      f = "Wrapper:simple:" + caller.name;
      route_logic = (ref = caller.version[(ref1 = req.params) != null ? ref1.Version : void 0]) != null ? ref : caller.version.any;
      if (req === 'use') {
        return route_logic(req);
      }
      if (caller.auth_required) {
        if (!req.auth.authorize()) {
          return next();
        }
      }
      return route_logic(req, res, next);
    };

    Wrapper.prototype.auth = function(req, res, next, caller) {
      var ctx, f, p, pre_loaded, ref, ref1, ref2, route_logic, send_result, supported_grant_type;
      f = "Wrapper:auth";
      if (!this.config.db.mysql.enable) {
        throw new this.E.ServerError('WRAPPER:AUTH:MYSQL_NOT_ENABLED');
      }
      route_logic = (ref = caller.version[(ref1 = req.params) != null ? ref1.Version : void 0]) != null ? ref : caller.version.any;
      if (req === 'use') {
        return (caller.use !== true ? caller.use : route_logic(req));
      }
      ctx = {
        conn: null,
        p: req.params,
        log: req.log
      };
      p = ctx.p;
      pre_loaded = {};
      send_result = false;
      supported_grant_type = (ref2 = p.grant_type) === 'password' || ref2 === 'refresh_token' || ref2 === 'client_credentials' ? true : false;
      this.start_connection_limit();
      p.request_count = request_count;
      p.request_count_high = request_count_high;
      return Promise.resolve().bind(this).then(function() {
        if (!p.client_id) {
          throw new this.E.MissingArg('client_id');
        }
        if (!supported_grant_type) {
          throw new this.E.OAuthError(400, 'unsupported_grant_type');
        }
        return this.sdb.core.Acquire();
      }).then(function(c) {
        if (c !== false) {
          ctx.conn = c;
        }
        return this.sdb.core.StartTransaction(ctx);
      }).then(function() {
        return route_logic(ctx, pre_loaded);
      }).then(function(result_hash) {
        send_result = result_hash.send;
        return this.sdb.core.sqlQuery(ctx, 'COMMIT');
      }).then(function(db_result) {
        if (ctx.conn !== null) {
          this.sdb.core.release(ctx.conn);
        }
        res.send(send_result);
        this.end_connection_limit();
        return next();
      })["catch"](function(err) {
        var ref3;
        if ((ref3 = err.statusCode) !== 400 && ref3 !== 401 && ref3 !== 403) {
          req.log.error(f, '.catch', err, err.stack);
        } else {
          req.log.debug(f, '.catch', err, err.stack);
        }
        if (err.body && err.body.error === 'invalid_client') {
          res.setHeader('WWW-Authenticate', "Bearer realm=" + this.config.auth.bearer);
        }
        if (ctx.conn !== null) {
          ctx.conn.query('ROLLBACK', (function(_this) {
            return function(err) {
              if (err) {
                req.log.warn(f, 'destroy db conn (failed rollback)');
                _this.sdb.core.destroy(ctx.conn);
                return req.log.error(f, '.catch', err.stack);
              } else {
                req.log.debug(f, 'release db conn (successful rollback)');
                return _this.sdb.core.release(ctx.conn);
              }
            };
          })(this));
        }
        res.send(err.body ? err : new this.E.ServerError(err.name, err.message));
        this.end_connection_limit();
        return next();
      });
    };

    Wrapper.prototype["default"] = function(req, res, next, endpoint) {
      var ctx, f, p, pre_loaded, ref, ref1, ref2, ref3, result, route_logic;
      f = "Wrapper:default:" + endpoint.name;
      route_logic = (ref = endpoint.version[(ref1 = req.params) != null ? ref1.Version : void 0]) != null ? ref : endpoint.version.any;
      if (req === 'use') {
        return (endpoint.use !== true ? endpoint.use : route_logic(req));
      }
      ctx = {
        conn: null,
        p: req.params,
        log: req.log,
        auth_id: (ref2 = req.auth) != null ? ref2.authId : void 0,
        files: req.files,
        req: req,
        res: res,
        spec: endpoint,
        lamd: {
          start: new Date().getTime(),
          route: endpoint.route,
          verb: endpoint.verb,
          params: req.params,
          headers: req.headers,
          req_uuid: req._id,
          auth_id: 0
        }
      };
      p = ctx.p;
      pre_loaded = {};
      result = false;
      if (endpoint.auth_required || endpoint.permit) {
        if (((ref3 = this.config.perf) != null ? ref3.test_user_override : void 0) === true && typeof p.mock_id === "string") {
          pre_loaded.auth_id = Number(p.mock_id);
        } else {
          if (!req.auth.authorize()) {
            return next();
          }
          pre_loaded.auth_id = req.auth.authId;
        }
        ctx.lamd.auth_id = pre_loaded.auth_id;
      }
      return Promise.resolve().bind(this).then(function() {
        this.start_connection_limit();
        p.request_count = ctx.lamd.request_count = request_count;
        return p.request_count_high = request_count_high;
      }).then(function() {
        if (!endpoint.mongo_pool) {
          return false;
        }
        if (!(endpoint.mongo_pool in this.odb.pool)) {
          throw new this.E.ServerError('WRAPPER:DEFAULT:UNKNOWN_MONGO_POOL:' + endpoint.mongo_pool);
        }
        return ctx.pool = this.odb.pool[endpoint.mongo_pool];
      }).then(function() {
        if (!endpoint.sql_conn) {
          return false;
        }
        if (!this.config.db.mysql.enable) {
          throw new this.E.ServerError('WRAPPER:DEFAULT:MYSQL_NOT_ENABLED');
        }
        return this.sdb.core.Acquire();
      }).then(function(c) {
        if (c !== false) {
          ctx.conn = c;
        }
        if (!endpoint.sql_tx) {
          return false;
        }
        if (!this.config.db.mysql.enable) {
          throw new this.E.ServerError('WRAPPER:DEFAULT:MYSQL_NOT_ENABLED');
        }
        return this.sdb.core.StartTransaction(ctx);
      }).then(function() {
        var fn, func, nm, q_result, ref4;
        q_result = Promise.resolve().bind(this);
        ref4 = endpoint.pre_load;
        fn = (function(_this) {
          return function(nm, func) {
            return q_result = q_result.then(function() {
              return func(ctx, pre_loaded);
            }).then(function(pre_load_result) {
              ctx.log.debug(f + ':pre-load', "got " + nm + ":", pre_load_result);
              return pre_loaded[nm] = pre_load_result;
            });
          };
        })(this);
        for (nm in ref4) {
          func = ref4[nm];
          fn(nm, func);
        }
        return q_result;
      }).then(function() {
        return route_logic(ctx, pre_loaded);
      }).then(function(result_hash) {
        result = result_hash;
        if (!endpoint.sql_conn) {
          return false;
        }
        return this.sdb.core.sqlQuery(ctx, 'COMMIT');
      }).then(function(db_result) {
        var end;
        delete ctx.pool;
        if (ctx.conn !== null) {
          this.sdb.core.release(ctx.conn);
        }
        if (!endpoint.is_websock) {
          res.send(result.send);
        }
        ctx.lamd.statusCode = res.statusCode;
        end = new Date().getTime();
        ctx.lamd.duration = end - ctx.lamd.start;
        if (endpoint.lamd !== false) {
          this.lamd.write(ctx.lamd);
        }
        this.end_connection_limit();
        return next();
      })["catch"](function(err) {
        var end, ref4;
        delete ctx.pool;
        if ((ref4 = err.statusCode) !== 400 && ref4 !== 403) {
          req.log.error(f, '.catch', err, err.stack);
        } else {
          req.log.debug(f, '.catch', err);
        }
        if (ctx.conn !== null) {
          ctx.conn.query('ROLLBACK', (function(_this) {
            return function(err) {
              if (err) {
                req.log.warn(f, 'destroy db conn (failed rollback)');
                _this.sdb.core.destroy(ctx.conn);
                return req.log.error(f, '.catch', err.stack);
              } else {
                req.log.debug(f, 'release db conn (successful rollback)');
                return _this.sdb.core.release(ctx.conn);
              }
            };
          })(this));
        }
        res.send(err.body ? err : new this.E.ServerError(err.name, err.message));
        ctx.lamd.statusCode = res.statusCode;
        end = new Date().getTime();
        ctx.lamd.duration = end - ctx.lamd.start;
        ctx.lamd.err = this._exposeErrorProperties(err);
        this.lamd.write(ctx.lamd);
        this.end_connection_limit();
        return next();
      });
    };

    Wrapper.prototype._exposeErrorProperties = function(error) {
      var copy;
      copy = Object.assign({}, error);
      if (error.name) {
        copy.name = error.name;
      }
      if (error.message) {
        copy.message = error.message;
      }
      return copy;
    };

    return Wrapper;

  })();

  exports.Wrapper = Wrapper;

}).call(this);
