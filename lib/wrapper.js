// Generated by CoffeeScript 1.6.3
(function() {
  var E, Q, Wrapper, config, odb, sdb, _log,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Q = require('q');

  E = require('./error');

  _log = false;

  odb = false;

  sdb = false;

  config = false;

  Wrapper = (function() {
    function Wrapper(kit) {
      this.add = __bind(this.add, this);
      this.add_wrap = __bind(this.add_wrap, this);
      kit.services.logger.log.info('Initializing Wrapper...');
      _log = kit.services.logger.log;
      odb = kit.services.db.mongo;
      sdb = kit.services.db.mysql;
      config = kit.services.config;
      this.routes = kit.routes;
      this.router = kit.services.router;
      this.wraps = {};
    }

    Wrapper.prototype.add_wrap = function(mod, wrap) {
      return this.wraps[mod] = wrap;
    };

    Wrapper.prototype.add = function(mod) {
      var endpoint, f, func, wrap, _ref, _results;
      f = 'Wrapper:add:';
      if (mod in this.wraps) {
        return this.wraps[mod](mod);
      }
      _ref = this.routes[mod].endpoints;
      _results = [];
      for (func in _ref) {
        endpoint = _ref[func];
        endpoint.name = mod + ':' + func;
        wrap = this[endpoint.wrap](endpoint);
        _results.push(this.router.add_route(mod, func, endpoint.verb, endpoint.route, wrap));
      }
      return _results;
    };

    Wrapper.prototype.auth_wrap = function(caller) {
      var auth_func;
      auth_func = this.auth;
      return function(q, s, n) {
        return auth_func(q, s, n, caller);
      };
    };

    Wrapper.prototype.default_wrap = function(caller) {
      var func;
      func = this["default"];
      return function(q, s, n) {
        return func(q, s, n, caller);
      };
    };

    Wrapper.prototype.simple_wrap = function(caller) {
      var func;
      func = this.simple;
      return function(q, s, n) {
        return func(q, s, n, caller);
      };
    };

    Wrapper.prototype.simple = function(req, res, next, caller) {
      var f, route_logic, _ref, _ref1;
      f = "Wrapper:simple:" + caller.name;
      route_logic = (_ref = caller.version[(_ref1 = req.params) != null ? _ref1.Version : void 0]) != null ? _ref : caller.version.any;
      if (req === 'use') {
        return route_logic(req);
      }
      if (caller.auth_required) {
        if (!req.auth.authorize()) {
          return next();
        }
      }
      return route_logic(req, res, next);
    };

    Wrapper.prototype.auth = function(req, res, next, caller) {
      var ctx, f, p, pre_loaded, route_logic, send_result, supported_grant_type, _ref, _ref1, _ref2;
      f = "Wrapper:auth";
      if (!config.db.mysql.enable) {
        throw new E.ServerError('WRAPPER:AUTH:MYSQL_NOT_ENABLED');
      }
      route_logic = (_ref = caller.version[(_ref1 = req.params) != null ? _ref1.Version : void 0]) != null ? _ref : caller.version.any;
      if (req === 'use') {
        return (caller.use !== true ? caller.use : route_logic(req));
      }
      ctx = {
        conn: null,
        p: req.params,
        log: req.log
      };
      p = ctx.p;
      pre_loaded = {};
      send_result = false;
      supported_grant_type = (_ref2 = p.grant_type) === 'password' || _ref2 === 'refresh_token' ? true : false;
      return Q.resolve().then(function() {
        if (!p.client_id) {
          throw new E.OAuthError(400, 'unauthorized_client');
        }
        if (!supported_grant_type) {
          throw new E.OAuthError(400, 'unsupported_grant_type');
        }
        return sdb.core.Acquire();
      }).then(function(c) {
        if (c !== false) {
          ctx.conn = c;
        }
        return sdb.core.StartTransaction(ctx);
      }).then(function() {
        return route_logic(ctx, pre_loaded);
      }).then(function(result_hash) {
        send_result = result_hash.send;
        return sdb.core.sqlQuery(ctx, 'COMMIT');
      }).then(function(db_result) {
        if (ctx.conn !== null) {
          sdb.core.release(ctx.conn);
        }
        res.send(send_result);
        return next();
      }).fail(function(err) {
        var _ref3;
        if ((_ref3 = err.statusCode) !== 400 && _ref3 !== 401 && _ref3 !== 403) {
          req.log.error(f, '.fail', err, err.stack);
        } else {
          req.log.debug(f, '.fail', err);
        }
        if (err.body && err.body.error === 'invalid_client') {
          res.setHeader('WWW-Authenticate', "Bearer realm=" + config.auth.bearer);
        }
        if (ctx.conn !== null) {
          ctx.conn.query('ROLLBACK', function(err) {
            if (err) {
              req.log.warn(f, 'destroy db conn (failed rollback)');
              sdb.core.destroy(ctx.conn);
              return req.log.error(f, '.fail', err.stack);
            } else {
              req.log.debug(f, 'release db conn (successful rollback)');
              return sdb.core.release(ctx.conn);
            }
          });
        }
        res.send(err);
        return next();
      });
    };

    Wrapper.prototype["default"] = function(req, res, next, caller) {
      var ctx, f, p, pre_loaded, result, route_logic, _ref, _ref1;
      f = "Wrapper:default:" + caller.name;
      route_logic = (_ref = caller.version[(_ref1 = req.params) != null ? _ref1.Version : void 0]) != null ? _ref : caller.version.any;
      if (req === 'use') {
        return (caller.use !== true ? caller.use : route_logic(req));
      }
      ctx = {
        conn: null,
        p: req.params,
        log: req.log,
        auth_id: req.auth.authId
      };
      p = ctx.p;
      pre_loaded = {};
      result = false;
      if (caller.auth_required) {
        if (!req.auth.authorize()) {
          return next();
        }
        pre_loaded.auth_id = req.auth.authId;
      }
      return Q.resolve().then(function() {
        if (!caller.sql_conn) {
          return false;
        }
        if (!config.db.mysql.enable) {
          throw new E.ServerError('WRAPPER:DEFAULT:MYSQL_NOT_ENABLED');
        }
        return sdb.core.Acquire();
      }).then(function(c) {
        if (c !== false) {
          ctx.conn = c;
        }
        if (!caller.sql_tx) {
          return false;
        }
        if (!config.db.mysql.enable) {
          throw new E.ServerError('WRAPPER:DEFAULT:MYSQL_NOT_ENABLED');
        }
        return sdb.core.StartTransaction(ctx);
      }).then(function() {
        var func, nm, q_result, _fn, _ref2;
        q_result = Q.resolve(true);
        _ref2 = caller.pre_load;
        _fn = function(nm, func) {
          return q_result = q_result.then(function() {
            return func(ctx);
          }).then(function(pre_load_result) {
            _log.debug("got " + nm + ":", pre_load_result);
            return pre_loaded[nm] = pre_load_result;
          });
        };
        for (nm in _ref2) {
          func = _ref2[nm];
          _fn(nm, func);
        }
        return q_result;
      }).then(function() {
        return route_logic(ctx, pre_loaded);
      }).then(function(result_hash) {
        result = result_hash;
        if (!caller.sql_conn) {
          return false;
        }
        return sdb.core.sqlQuery(ctx, 'COMMIT');
      }).then(function(db_result) {
        if (ctx.conn !== null) {
          sdb.core.release(ctx.conn);
        }
        res.send(result.send);
        return next();
      }).fail(function(err) {
        var _ref2;
        if ((_ref2 = err.statusCode) !== 400 && _ref2 !== 403) {
          req.log.error(f, '.fail', err, err.stack);
        } else {
          req.log.debug(f, '.fail', err);
        }
        if (ctx.conn !== null) {
          ctx.conn.query('ROLLBACK', function(err) {
            if (err) {
              req.log.warn(f, 'destroy db conn (failed rollback)');
              sdb.core.destroy(ctx.conn);
              return req.log.error(f, '.fail', err.stack);
            } else {
              req.log.debug(f, 'release db conn (successful rollback)');
              return sdb.core.release(ctx.conn);
            }
          });
        }
        res.send(err);
        return next();
      });
    };

    return Wrapper;

  })();

  exports.Wrapper = Wrapper;

}).call(this);
