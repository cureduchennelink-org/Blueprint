// Generated by CoffeeScript 1.9.2
(function() {
  var AWS, Promise, S3Proxy, crypto,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Promise = require("bluebird");

  AWS = require('aws-sdk');

  crypto = require('crypto');

  S3Proxy = (function() {
    S3Proxy.deps = {
      services: ['config'],
      config: 's3_creds[secretKey,accessKey,bucket,endpoint,region]'
    };

    function S3Proxy(kit) {
      this._s3UploadPolicy = bind(this._s3UploadPolicy, this);
      this._s3Params = bind(this._s3Params, this);
      this.s3RemoveFile = bind(this.s3RemoveFile, this);
      this.s3UploadBuffer = bind(this.s3UploadBuffer, this);
      this.s3GetUrl = bind(this.s3GetUrl, this);
      this.s3Credentials = bind(this.s3Credentials, this);
      var f;
      f = 'S3Proxy:constructor';
      this.config = kit.services.config.s3_creds;
      AWS.config.update({
        accessKeyId: this.config.accessKey,
        secretAccessKey: this.config.secretKey,
        region: this.config.region
      });
      this.s3 = new AWS.S3({
        apiVersion: '2006-03-01'
      });
      this.s3_getSignedUrl = Promise.promisify(this.s3.getSignedUrl).bind(this.s3);
      this.s3_putObject = Promise.promisify(this.s3.putObject).bind(this.s3);
      this.s3_deleteObject = Promise.promisify(this.s3.deleteObject).bind(this.s3);
    }

    S3Proxy.prototype.s3Credentials = function(ctx, params) {
      var result;
      result = {
        endpoint_url: this.config.endpoint,
        params: this._s3Params(params)
      };
      ctx.log.debug(f, {
        params: params,
        result: result
      });
      return result;
    };

    S3Proxy.prototype.s3GetUrl = function(ctx, key, expires, bucket) {
      var f, params;
      if (expires == null) {
        expires = 60 * 60;
      }
      if (bucket == null) {
        bucket = this.config.bucket;
      }
      f = 'S3Proxy:s3GetUrl';
      params = {
        Bucket: bucket,
        Key: key,
        Expires: expires
      };
      ctx.log.debug(f, params);
      return this.s3_getSignedUrl('getObject', params);
    };

    S3Proxy.prototype.s3UploadBuffer = function(ctx, buffer, key, content_type, bucket) {
      var f, params;
      if (bucket == null) {
        bucket = this.config.bucket;
      }
      f = 'S3Proxy:s3UploadBuffer';
      params = {
        Bucket: bucket,
        Key: key,
        ContentEncoding: 'buffer',
        ContentType: content_type,
        ACL: 'public-read'
      };
      ctx.log.debug(f, params);
      params.Body = buffer;
      return this.s3_putObject(params).then(function() {
        return "https://s3.amazonaws.com/" + bucket + "/" + key;
      });
    };

    S3Proxy.prototype.s3RemoveFile = function(ctx, key, bucket) {
      var f, params, send;
      if (bucket == null) {
        bucket = this.config.bucket;
      }
      f = 'S3Proxy:s3RemoveFile';
      send = {
        success: false
      };
      params = {
        Bucket: bucket,
        Key: key
      };
      ctx.log.debug(f, params);
      return this.s3.deleteObject(params).then(function() {
        return "https://s3.amazonaws.com/" + bucket + "/" + key;
      });
    };

    S3Proxy.prototype._s3Params = function(params) {
      var credential, details, policy, policyBase64;
      credential = this._amzCredential();
      policy = this._s3UploadPolicy(params, credential);
      policyBase64 = new Buffer(JSON.stringify(policy)).toString('base64');
      details = {
        key: params.filename,
        acl: this.config.encrypted ? 'bucket-owner-full-control' : 'public-read',
        success_action_status: '201',
        policy: policyBase64,
        'Content-Type': params.contentType,
        'x-amz-algorithm': 'AWS4-HMAC-SHA256',
        'x-amz-credential': credential,
        'x-amz-date': this._dateString() + 'T000000Z',
        'x-amz-signature': this._s3UploadSignature(policyBase64, credential)
      };
      if (this.config.encrypted) {
        details['x-amz-server-side-encryption'] = 'AES256';
      }
      return details;
    };

    S3Proxy.prototype._dateString = function() {
      var date;
      date = (new Date).toISOString();
      return date.substr(0, 4) + date.substr(5, 2) + date.substr(8, 2);
    };

    S3Proxy.prototype._amzCredential = function() {
      return [this.config.accessKey, this._dateString(), this.config.region, 's3/aws4_request'].join('/');
    };

    S3Proxy.prototype._s3UploadPolicy = function(params, credential) {
      var conditions, expiration;
      expiration = new Date((new Date).getTime() + 5 * 60 * 1000).toISOString();
      conditions = [
        {
          bucket: this.config.bucket
        }, {
          key: params.filename
        }, {
          acl: this.config.encrypted ? 'bucket-owner-full-control' : 'public-read'
        }, {
          success_action_status: '201'
        }, ['starts-with', '$Content-Type', ''], ['content-length-range', 0, 5000000000], {
          'x-amz-algorithm': 'AWS4-HMAC-SHA256'
        }, {
          'x-amz-credential': credential
        }, {
          'x-amz-date': this._dateString() + 'T000000Z'
        }
      ];
      if (this.config.encrypted) {
        conditions.push(['eq', '$x-amz-server-side-encryption', 'AES256']);
      }
      return {
        expiration: expiration,
        conditions: conditions
      };
    };

    S3Proxy.prototype._hmac = function(key, string) {
      var self;
      self = crypto.createHmac('sha256', key);
      self.end(string);
      return self.read();
    };

    S3Proxy.prototype._s3UploadSignature = function(policyBase64, credential) {
      var dateKey, dateRegionKey, dateRegionServiceKey, signingKey;
      dateKey = this._hmac('AWS4' + this.config.secretKey, this._dateString());
      dateRegionKey = this._hmac(dateKey, this.config.region);
      dateRegionServiceKey = this._hmac(dateRegionKey, 's3');
      signingKey = this._hmac(dateRegionServiceKey, 'aws4_request');
      return this._hmac(signingKey, policyBase64).toString('hex');
    };

    return S3Proxy;

  })();

  exports.S3Proxy = S3Proxy;

}).call(this);
