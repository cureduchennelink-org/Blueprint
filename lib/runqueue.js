// Generated by CoffeeScript 1.9.2
(function() {
  var Promise, RunQueue, VALID_UNITS, _, it_is, moment,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Promise = require('bluebird');

  _ = require('lodash');

  it_is = require('is_js');

  moment = require('moment');

  VALID_UNITS = ['months', 'M', 'weeks', 'w', 'days', 'd', 'hours', 'h', 'minutes', 'm', 'seconds', 's'];

  RunQueue = (function() {
    RunQueue.deps = {
      services: ['config', 'error'],
      mysql: ['runqueue'],
      config: ['runqueue.topic_defaults{back_off,last_fail,priority,external_group,limit,alarm_cnt,warn_cnt,warn_delay,alarm_delay}', 'runqueue.external_groups[default/ANY{connections,requests}]', 'runqueue.topics.ANY{call,type,priority,run_at,external_group}', 'runqueue.settings[poll_interval_ms,jobs,read_depth]', 'runqueue[mongodb_uri,mongodb_name]']
    };

    function RunQueue(kit) {
      this._Poll = bind(this._Poll, this);
      this.server_start = bind(this.server_start, this);
      var f, group_defaults, nm, rec, ref, ref1;
      f = 'RunQueue::constructor';
      this.log = kit.services.logger.log;
      this.E = kit.services.error;
      this.sdb = kit.services.db.mysql;
      this.config = kit.services.config.runqueue;
      this.ctx_poll = {
        log: this.log,
        conn: false
      };
      this.poll_timer_id = false;
      this.poll_processing = false;
      this.job_cnt = 0;
      this.ctx_finish = {
        log: this.log,
        conn: false
      };
      this.finish_promise = Promise.resolve().bind(this);
      this.topics = {};
      ref = this.config.topics;
      for (nm in ref) {
        rec = ref[nm];
        this.topics[nm] = _.merge({
          nm: nm
        }, this.config.topic_defaults, rec);
      }
      this.groups = {};
      group_defaults = this.config.external_groups['default'];
      ref1 = this.config.external_groups;
      for (nm in ref1) {
        rec = ref1[nm];
        if (nm !== 'default') {
          this.groups[nm] = _.merge({}, group_defaults, rec);
        }
      }
      this.log.debug(f, {
        topics: this.topics,
        groups: this.groups
      });
      this.ERR_DUPLICATE_JOB = "DuplicateJobError";
    }

    RunQueue.prototype._back_off_strategies = {
      standard: function(retries) {
        if (retries === 0) {
          return 0;
        } else {
          return retries ^ 4 + 5 + this.standard(retries - 1);
        }
      },
      year: function(retries) {
        if (retries === 0) {
          return 0;
        } else {
          return 365 * 24 * 60 * 60;
        }
      },
      immediate: function(retries) {
        return 0;
      }
    };

    RunQueue.prototype.server_start = function(kit) {
      var f, interval_ms, method, nm, ref, ref1, service, topic;
      f = 'RunQueue::server_start:';
      ref = this.topics;
      for (nm in ref) {
        topic = ref[nm];
        topic.nm = nm;
        this.log.debug(f, {
          topic: topic
        });
        ref1 = topic.service.split('.'), service = ref1[0], method = ref1[1];
        if (!(service in kit.services)) {
          throw new Error("KIT DOES NOT HAVE SERVICE (" + service + ") MENTIONED IN TOPIC (" + nm + ") AS [" + topic.service + "]");
        }
        if (!it_is.string(topic.back_off)) {
          throw new Error("KIT DOES NOT HAVE BACK OFF STRATEGY IN TOPIC (" + nm + ")");
        }
        if (!it_is["function"](this._back_off_strategies[topic.back_off])) {
          throw new Error("UNKNOWN BACK OFF STRATEGY " + topic.back_off + " IN TOPIC " + nm + " should be one of [" + (Object.keys(this._back_off_strategies)) + "]");
        }
        if (!(method in kit.services[service])) {
          throw new Error("METHOD (" + method + ") NOT FOUND IN SERVICE (" + service + ") MENTIONED IN TOPIC (" + nm + ") AS [" + topic.service + "]");
        }
        topic._method = kit.services[service][method];
        if (!it_is["function"](topic._method)) {
          throw new Error("NOT A FUNCTION: (" + topic.service + ") MENTIONED IN TOPIC (" + nm + ")");
        }
        topic.alarm_delay_sec = this._calc_secs(topic.alarm_delay, nm + ".alarm_delay");
        topic.warn_delay_sec = this._calc_secs(topic.warn_delay, nm + ".warn_delay");
      }
      interval_ms = this.config.settings.poll_interval_ms;
      if (interval_ms !== false) {
        this.poll_timer_id = setInterval(this._Poll, interval_ms);
      }
      return Promise.resolve().bind(this).then(function() {
        return this.sdb.core.Acquire();
      }).then(function(c) {
        return this.ctx_finish.conn = c;
      });
    };

    RunQueue.prototype._pick_at = function(retries, which, topic, other_object) {
      var at, back_off_strategy, f, resolved_topic;
      f = 'RunQueue::_pick_at:';
      resolved_topic = it_is.string(topic) ? this.topics[topic] : topic;
      if (it_is.object(other_object) && other_object[which]) {
        at = other_object[which];
      } else {
        at = resolved_topic[which];
      }
      back_off_strategy = resolved_topic['back_off'];
      if (it_is.array(at)) {
        return this._calc_at(this._back_off_strategies[back_off_strategy](retries), at, resolved_topic.nm + ":" + which);
      } else {
        return moment(at).format();
      }
    };

    RunQueue.prototype._validate_format = function(spec, name) {
      var ref;
      if ((it_is.array(spec)) && (it_is.number(spec[0])) && (it_is.string(spec[1])) && (ref = spec[1], indexOf.call(VALID_UNITS, ref) >= 0)) {
        return true;
      } else {
        throw new Error("SPEC (" + name + ") WAS NOT AN ARRAY OF NUMBER AND STRING-UNIT (" + spec + ")");
      }
    };

    RunQueue.prototype._calc_secs = function(spec, name) {
      this._validate_format(spec, name);
      return moment(0).add(spec[0], spec[1]).unix();
    };

    RunQueue.prototype._calc_at = function(base, spec, name) {
      this._validate_format(spec, name);
      return moment().add(base, 's').add(spec[0], spec[1]).format();
    };

    RunQueue.prototype.AddJob = function(ctx, details, job_id) {
      var allowed_details, defaults, f, i, len, new_values, nm, only_topics, ref, topic;
      if (job_id == null) {
        job_id = false;
      }
      f = 'RunQueue::AddJob:';
      if (job_id === false) {
        ref = ['topic', 'json'];
        for (i = 0, len = ref.length; i < len; i++) {
          nm = ref[i];
          if (!(nm in details)) {
            console.log(this.E.MissingArg(nm));
          }
          if (!(nm in details)) {
            throw this.E.MissingArg(nm);
          }
        }
        if (!(details.topic in this.topics)) {
          throw new this.E.InvalidArg("topic (" + details.topic + ")");
        }
      }
      topic = this.topics[details.topic];
      defaults = _.pick(topic, ['priority', 'unique_key']);
      only_topics = _.pick(topic, ['group_ref']);
      allowed_details = _.pick(details, ['topic', 'unique_key', 'priority', 'json']);
      allowed_details.run_at = this._pick_at(0, 'run_at', topic, details);
      new_values = _.merge(defaults, allowed_details, only_topics);
      return Promise.resolve().bind(this).then(function() {
        var replace_values, reread;
        if (job_id === false) {
          return this.sdb.runqueue.AddJob(ctx, new_values, reread = true);
        } else {
          replace_values = _.pick(new_values, ['unique_key', 'priority', 'run_at', 'json']);
          return this.sdb.runqueue.ReplaceJob(ctx, job_id, replace_values, reread = true);
        }
      })["catch"](function(e) {
        if ((e.errno === 1062 && e.sqlMessage.includes("ix_runqueue__unique_key")) || (e.code === 11000 && e.errmsg.includes('duplicate key error collection'))) {
          e.name = this.ERR_DUPLICATE_JOB;
        }
        throw e;
      });
    };

    RunQueue.prototype.RemoveJobsByIds = function(ids) {
      var f;
      f = 'RunQueue::RemoveJobsByIds:';
      this.finish_promise = this.finish_promise.then(function() {
        return Promise.resolve().bind(this).then(function() {
          return this.sdb.runqueue.RemoveByIds(this.ctx_finish, ids);
        })["catch"](function(e) {
          return this.log.error(f, e);
        });
      });
    };

    RunQueue.prototype.RemoveJobsByUniqueIds = function(uniqueIds) {
      var f;
      f = 'RunQueue::RemoveJobsByUniqueIds:';
      this.finish_promise = this.finish_promise.then(function() {
        return Promise.resolve().bind(this).then(function() {
          return this.sdb.runqueue.RemoveByExtern(this.ctx_finish, uniqueIds);
        })["catch"](function(e) {
          return this.log.error(f, e);
        });
      });
    };

    RunQueue.prototype._set_status = function(status_obj, status, detail_name, row) {
      if (status === 'r' || status_obj.status === 'g') {
        status_obj.status = status;
      }
      if (status_obj.details[detail_name] === void 0) {
        status_obj.details[detail_name] = [];
      }
      return status_obj.details[detail_name].push(row);
    };

    RunQueue.prototype.HealthCheck = function(ctx) {
      var f, status;
      f = 'RunQueue::HealthCheck:';
      status = {
        status: 'g',
        details: {}
      };
      return Promise.resolve().bind(this).then(function() {
        return this.sdb.runqueue.GetDelayedByTopic(ctx);
      }).then(function(result) {
        var i, len, row, topic;
        for (i = 0, len = result.length; i < len; i++) {
          row = result[i];
          topic = this.topics[row.topic];
          if (row.delay >= topic.alarm_delay_sec) {
            this._set_status(status, 'r', 'delays', row);
          } else if (row.delay >= topic.warn_delay_sec) {
            this._set_status(status, 'y', 'delays', row);
          }
        }
        return this.sdb.runqueue.GetRetriesByTopic(ctx);
      }).then(function(result) {
        var i, len, row, topic;
        for (i = 0, len = result.length; i < len; i++) {
          row = result[i];
          topic = this.topics[row.topic];
          if (row.max_retries >= topic.alarm_cnt) {
            this._set_status(status, 'r', 'retries', row);
          } else if (row.max_retries >= topic.warn_cnt) {
            this._set_status(status, 'y', 'retries', row);
          }
        }
        return this.sdb.runqueue.GetFailuresByTopic(ctx);
      }).then(function(result) {
        if (!it_is.empty(result)) {
          status.status = 'r';
          status.details.failures = result;
        }
        return status;
      });
    };

    RunQueue.prototype._Poll = function() {
      var ctx, f, group_cnt, job, nm, rVal, rec, ref;
      f = 'RunQueue::_Poll:';
      rVal = [];
      this.log.debug(f, {
        poll_processing: this.poll_processing,
        job_cnt: this.job_cnt
      });
      if (this.poll_processing === true) {
        return {
          stop: 'poll_processing'
        };
      }
      this.poll_processing = true;
      if (this.job_cnt > this.config.settings.jobs) {
        return {
          stop: 'job_cnt'
        };
      }
      ctx = this.ctx_poll;
      job = false;
      group_cnt = {};
      ref = this.groups;
      for (nm in ref) {
        rec = ref[nm];
        group_cnt[nm] = rec.connections;
      }
      return Promise.resolve().bind(this).then(function() {
        if (ctx.conn !== false) {
          return false;
        }
        rVal.push({
          step: 'acquire'
        });
        return this.sdb.core.Acquire();
      }).then(function(c) {
        if (c !== false) {
          ctx.conn = c;
        }
        rVal.push({
          pre_group_cnt: _.clone(group_cnt)
        });
        return this.sdb.runqueue.GetPendingCnts(ctx);
      }).then(function(db_rows) {
        var i, len;
        for (i = 0, len = db_rows.length; i < len; i++) {
          rec = db_rows[i];
          group_cnt[rec.group_ref] -= rec.active_cnt;
        }
        rVal.push({
          post_group_cnt: _.clone(group_cnt)
        });
        return this.sdb.runqueue.GetNextJobs(ctx, this.config.settings.read_depth);
      }).then(function(db_rows) {
        var fn, i, len, q_result;
        rVal.push({
          next_jobs: db_rows
        });
        if (db_rows.length === 0) {
          this.poll_processing = false;
          return false;
        }
        q_result = Promise.resolve().bind(this);
        fn = (function(_this) {
          return function(job) {
            return q_result = q_result.then(function() {
              var fail_at, reread;
              fail_at = this._calc_at(0, this.topics[job.topic].fail_at, job.topic + '.fail_at');
              return this.sdb.runqueue.MarkJobPending(ctx, job.id, {
                fail_at: fail_at
              }, reread = true);
            }).then(function(db_rows) {
              rVal.push({
                MarkJobPending_result: db_rows
              });
              if (db_rows.length !== 1) {
                return [false];
              }
              return Promise.resolve().bind(this).then(function() {
                return this.topics[job.topic]._method(job);
              }).then(function(topic_result) {
                rVal.push({
                  topic_method_result: topic_result
                });
                return [job, topic_result];
              })["catch"](function(e) {
                rVal.push({
                  topic_method_error: e
                });
                return [
                  job, {
                    error: e
                  }
                ];
              });
            }).then(function(arg) {
              var job, topic_result;
              job = arg[0], topic_result = arg[1];
              if (job === false) {
                return false;
              }
              return this._ProcessTopicResult(job, topic_result);
            }).then(function(process_result) {
              return rVal.push({
                process_result: process_result
              });
            });
          };
        })(this);
        for (i = 0, len = db_rows.length; i < len; i++) {
          job = db_rows[i];
          if (group_cnt[job.group_ref] < 1) {
            continue;
          }
          group_cnt[job.group_ref]--;
          fn(job);
        }
        this.poll_processing = false;
        return q_result;
      }).then(function() {
        return rVal;
      });
    };

    RunQueue.prototype._ProcessTopicResult = function(job, topic_result) {
      var ctx, f, ref, ref1;
      f = 'RunQueue::_ProcessTopicResult:';
      ctx = this.ctx_finish;
      this.log.debug(f + 'BEFORE', {
        topic_result: topic_result
      });
      if ('error' in topic_result) {
        topic_result = {
          success: false,
          reason: (ref = (ref1 = topic_result.error) != null ? ref1.stack : void 0) != null ? ref : topic_result.error.toString()
        };
      } else if (!('success' in topic_result)) {
        topic_result = {
          success: false,
          reason: "Bad Response: " + JSON.stringify(topic_result)
        };
      }
      this.log.debug(f + 'AFTER', {
        topic_result: topic_result
      });
      return this.finish_promise = this.finish_promise.then(function() {
        return Promise.resolve().bind(this).then(function() {
          var new_values, reread, run_at;
          if (topic_result.success === true) {
            if (topic_result.replace) {
              new_values = _.merge({
                topic: job.topic
              }, topic_result.replace);
              return this.AddJob(ctx, new_values, job.id);
            } else {
              return this.sdb.runqueue.RemoveByIds(ctx, job.id);
            }
          } else {
            run_at = this._pick_at(job.retries + 1, 'run_at', job.topic, topic_result);
            return this.sdb.runqueue.Fail(ctx, job.id, {
              run_at: run_at,
              last_reason: topic_result.reason
            }, reread = true);
          }
        })["catch"](function(err) {
          this.log.error(f, {
            job: job,
            topic_result: topic_result,
            err: err
          });
          return err;
        });
      });
    };

    return RunQueue;

  })();

  exports.RunQueue = RunQueue;

}).call(this);
